
./bin/matrix:     file format elf64-x86-64


Disassembly of section .init:

0000000000400a20 <_init>:
  400a20:	48 83 ec 08          	sub    $0x8,%rsp
  400a24:	48 8b 05 cd 35 20 00 	mov    0x2035cd(%rip),%rax        # 603ff8 <_DYNAMIC+0x1d0>
  400a2b:	48 85 c0             	test   %rax,%rax
  400a2e:	74 05                	je     400a35 <_init+0x15>
  400a30:	e8 cb 01 00 00       	callq  400c00 <sigaddset@plt+0x10>
  400a35:	48 83 c4 08          	add    $0x8,%rsp
  400a39:	c3                   	retq   

Disassembly of section .plt:

0000000000400a40 <sigprocmask@plt-0x10>:
  400a40:	ff 35 c2 35 20 00    	pushq  0x2035c2(%rip)        # 604008 <_GLOBAL_OFFSET_TABLE_+0x8>
  400a46:	ff 25 c4 35 20 00    	jmpq   *0x2035c4(%rip)        # 604010 <_GLOBAL_OFFSET_TABLE_+0x10>
  400a4c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400a50 <sigprocmask@plt>:
  400a50:	ff 25 c2 35 20 00    	jmpq   *0x2035c2(%rip)        # 604018 <_GLOBAL_OFFSET_TABLE_+0x18>
  400a56:	68 00 00 00 00       	pushq  $0x0
  400a5b:	e9 e0 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400a60 <putchar@plt>:
  400a60:	ff 25 ba 35 20 00    	jmpq   *0x2035ba(%rip)        # 604020 <_GLOBAL_OFFSET_TABLE_+0x20>
  400a66:	68 01 00 00 00       	pushq  $0x1
  400a6b:	e9 d0 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400a70 <__errno_location@plt>:
  400a70:	ff 25 b2 35 20 00    	jmpq   *0x2035b2(%rip)        # 604028 <_GLOBAL_OFFSET_TABLE_+0x28>
  400a76:	68 02 00 00 00       	pushq  $0x2
  400a7b:	e9 c0 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400a80 <puts@plt>:
  400a80:	ff 25 aa 35 20 00    	jmpq   *0x2035aa(%rip)        # 604030 <_GLOBAL_OFFSET_TABLE_+0x30>
  400a86:	68 03 00 00 00       	pushq  $0x3
  400a8b:	e9 b0 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400a90 <sigaction@plt>:
  400a90:	ff 25 a2 35 20 00    	jmpq   *0x2035a2(%rip)        # 604038 <_GLOBAL_OFFSET_TABLE_+0x38>
  400a96:	68 04 00 00 00       	pushq  $0x4
  400a9b:	e9 a0 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400aa0 <clone@plt>:
  400aa0:	ff 25 9a 35 20 00    	jmpq   *0x20359a(%rip)        # 604040 <_GLOBAL_OFFSET_TABLE_+0x40>
  400aa6:	68 05 00 00 00       	pushq  $0x5
  400aab:	e9 90 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400ab0 <__stack_chk_fail@plt>:
  400ab0:	ff 25 92 35 20 00    	jmpq   *0x203592(%rip)        # 604048 <_GLOBAL_OFFSET_TABLE_+0x48>
  400ab6:	68 06 00 00 00       	pushq  $0x6
  400abb:	e9 80 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400ac0 <printf@plt>:
  400ac0:	ff 25 8a 35 20 00    	jmpq   *0x20358a(%rip)        # 604050 <_GLOBAL_OFFSET_TABLE_+0x50>
  400ac6:	68 07 00 00 00       	pushq  $0x7
  400acb:	e9 70 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400ad0 <siglongjmp@plt>:
  400ad0:	ff 25 82 35 20 00    	jmpq   *0x203582(%rip)        # 604058 <_GLOBAL_OFFSET_TABLE_+0x58>
  400ad6:	68 08 00 00 00       	pushq  $0x8
  400adb:	e9 60 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400ae0 <gettimeofday@plt>:
  400ae0:	ff 25 7a 35 20 00    	jmpq   *0x20357a(%rip)        # 604060 <_GLOBAL_OFFSET_TABLE_+0x60>
  400ae6:	68 09 00 00 00       	pushq  $0x9
  400aeb:	e9 50 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400af0 <__assert_fail@plt>:
  400af0:	ff 25 72 35 20 00    	jmpq   *0x203572(%rip)        # 604068 <_GLOBAL_OFFSET_TABLE_+0x68>
  400af6:	68 0a 00 00 00       	pushq  $0xa
  400afb:	e9 40 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b00 <sched_setaffinity@plt>:
  400b00:	ff 25 6a 35 20 00    	jmpq   *0x20356a(%rip)        # 604070 <_GLOBAL_OFFSET_TABLE_+0x70>
  400b06:	68 0b 00 00 00       	pushq  $0xb
  400b0b:	e9 30 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b10 <sched_yield@plt>:
  400b10:	ff 25 62 35 20 00    	jmpq   *0x203562(%rip)        # 604078 <_GLOBAL_OFFSET_TABLE_+0x78>
  400b16:	68 0c 00 00 00       	pushq  $0xc
  400b1b:	e9 20 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b20 <__libc_start_main@plt>:
  400b20:	ff 25 5a 35 20 00    	jmpq   *0x20355a(%rip)        # 604080 <_GLOBAL_OFFSET_TABLE_+0x80>
  400b26:	68 0d 00 00 00       	pushq  $0xd
  400b2b:	e9 10 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b30 <calloc@plt>:
  400b30:	ff 25 52 35 20 00    	jmpq   *0x203552(%rip)        # 604088 <_GLOBAL_OFFSET_TABLE_+0x88>
  400b36:	68 0e 00 00 00       	pushq  $0xe
  400b3b:	e9 00 ff ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b40 <fprintf@plt>:
  400b40:	ff 25 4a 35 20 00    	jmpq   *0x20354a(%rip)        # 604090 <_GLOBAL_OFFSET_TABLE_+0x90>
  400b46:	68 0f 00 00 00       	pushq  $0xf
  400b4b:	e9 f0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b50 <syscall@plt>:
  400b50:	ff 25 42 35 20 00    	jmpq   *0x203542(%rip)        # 604098 <_GLOBAL_OFFSET_TABLE_+0x98>
  400b56:	68 10 00 00 00       	pushq  $0x10
  400b5b:	e9 e0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b60 <sigemptyset@plt>:
  400b60:	ff 25 3a 35 20 00    	jmpq   *0x20353a(%rip)        # 6040a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  400b66:	68 11 00 00 00       	pushq  $0x11
  400b6b:	e9 d0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b70 <malloc@plt>:
  400b70:	ff 25 32 35 20 00    	jmpq   *0x203532(%rip)        # 6040a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
  400b76:	68 12 00 00 00       	pushq  $0x12
  400b7b:	e9 c0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b80 <setitimer@plt>:
  400b80:	ff 25 2a 35 20 00    	jmpq   *0x20352a(%rip)        # 6040b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
  400b86:	68 13 00 00 00       	pushq  $0x13
  400b8b:	e9 b0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400b90 <perror@plt>:
  400b90:	ff 25 22 35 20 00    	jmpq   *0x203522(%rip)        # 6040b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
  400b96:	68 14 00 00 00       	pushq  $0x14
  400b9b:	e9 a0 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400ba0 <sysconf@plt>:
  400ba0:	ff 25 1a 35 20 00    	jmpq   *0x20351a(%rip)        # 6040c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
  400ba6:	68 15 00 00 00       	pushq  $0x15
  400bab:	e9 90 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400bb0 <exit@plt>:
  400bb0:	ff 25 12 35 20 00    	jmpq   *0x203512(%rip)        # 6040c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
  400bb6:	68 16 00 00 00       	pushq  $0x16
  400bbb:	e9 80 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400bc0 <fwrite@plt>:
  400bc0:	ff 25 0a 35 20 00    	jmpq   *0x20350a(%rip)        # 6040d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
  400bc6:	68 17 00 00 00       	pushq  $0x17
  400bcb:	e9 70 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400bd0 <sigaltstack@plt>:
  400bd0:	ff 25 02 35 20 00    	jmpq   *0x203502(%rip)        # 6040d8 <_GLOBAL_OFFSET_TABLE_+0xd8>
  400bd6:	68 18 00 00 00       	pushq  $0x18
  400bdb:	e9 60 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400be0 <__sigsetjmp@plt>:
  400be0:	ff 25 fa 34 20 00    	jmpq   *0x2034fa(%rip)        # 6040e0 <_GLOBAL_OFFSET_TABLE_+0xe0>
  400be6:	68 19 00 00 00       	pushq  $0x19
  400beb:	e9 50 fe ff ff       	jmpq   400a40 <_init+0x20>

0000000000400bf0 <sigaddset@plt>:
  400bf0:	ff 25 f2 34 20 00    	jmpq   *0x2034f2(%rip)        # 6040e8 <_GLOBAL_OFFSET_TABLE_+0xe8>
  400bf6:	68 1a 00 00 00       	pushq  $0x1a
  400bfb:	e9 40 fe ff ff       	jmpq   400a40 <_init+0x20>

Disassembly of section .plt.got:

0000000000400c00 <.plt.got>:
  400c00:	ff 25 f2 33 20 00    	jmpq   *0x2033f2(%rip)        # 603ff8 <_DYNAMIC+0x1d0>
  400c06:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

0000000000400c10 <_start>:
  400c10:	31 ed                	xor    %ebp,%ebp
  400c12:	49 89 d1             	mov    %rdx,%r9
  400c15:	5e                   	pop    %rsi
  400c16:	48 89 e2             	mov    %rsp,%rdx
  400c19:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  400c1d:	50                   	push   %rax
  400c1e:	54                   	push   %rsp
  400c1f:	49 c7 c0 80 2d 40 00 	mov    $0x402d80,%r8
  400c26:	48 c7 c1 10 2d 40 00 	mov    $0x402d10,%rcx
  400c2d:	48 c7 c7 b6 0f 40 00 	mov    $0x400fb6,%rdi
  400c34:	e8 e7 fe ff ff       	callq  400b20 <__libc_start_main@plt>
  400c39:	f4                   	hlt    
  400c3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400c40 <deregister_tm_clones>:
  400c40:	b8 07 41 60 00       	mov    $0x604107,%eax
  400c45:	55                   	push   %rbp
  400c46:	48 2d 00 41 60 00    	sub    $0x604100,%rax
  400c4c:	48 83 f8 0e          	cmp    $0xe,%rax
  400c50:	48 89 e5             	mov    %rsp,%rbp
  400c53:	76 1b                	jbe    400c70 <deregister_tm_clones+0x30>
  400c55:	b8 00 00 00 00       	mov    $0x0,%eax
  400c5a:	48 85 c0             	test   %rax,%rax
  400c5d:	74 11                	je     400c70 <deregister_tm_clones+0x30>
  400c5f:	5d                   	pop    %rbp
  400c60:	bf 00 41 60 00       	mov    $0x604100,%edi
  400c65:	ff e0                	jmpq   *%rax
  400c67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  400c6e:	00 00 
  400c70:	5d                   	pop    %rbp
  400c71:	c3                   	retq   
  400c72:	0f 1f 40 00          	nopl   0x0(%rax)
  400c76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  400c7d:	00 00 00 

0000000000400c80 <register_tm_clones>:
  400c80:	be 00 41 60 00       	mov    $0x604100,%esi
  400c85:	55                   	push   %rbp
  400c86:	48 81 ee 00 41 60 00 	sub    $0x604100,%rsi
  400c8d:	48 c1 fe 03          	sar    $0x3,%rsi
  400c91:	48 89 e5             	mov    %rsp,%rbp
  400c94:	48 89 f0             	mov    %rsi,%rax
  400c97:	48 c1 e8 3f          	shr    $0x3f,%rax
  400c9b:	48 01 c6             	add    %rax,%rsi
  400c9e:	48 d1 fe             	sar    %rsi
  400ca1:	74 15                	je     400cb8 <register_tm_clones+0x38>
  400ca3:	b8 00 00 00 00       	mov    $0x0,%eax
  400ca8:	48 85 c0             	test   %rax,%rax
  400cab:	74 0b                	je     400cb8 <register_tm_clones+0x38>
  400cad:	5d                   	pop    %rbp
  400cae:	bf 00 41 60 00       	mov    $0x604100,%edi
  400cb3:	ff e0                	jmpq   *%rax
  400cb5:	0f 1f 00             	nopl   (%rax)
  400cb8:	5d                   	pop    %rbp
  400cb9:	c3                   	retq   
  400cba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400cc0 <__do_global_dtors_aux>:
  400cc0:	80 3d 41 34 20 00 00 	cmpb   $0x0,0x203441(%rip)        # 604108 <completed.7585>
  400cc7:	75 11                	jne    400cda <__do_global_dtors_aux+0x1a>
  400cc9:	55                   	push   %rbp
  400cca:	48 89 e5             	mov    %rsp,%rbp
  400ccd:	e8 6e ff ff ff       	callq  400c40 <deregister_tm_clones>
  400cd2:	5d                   	pop    %rbp
  400cd3:	c6 05 2e 34 20 00 01 	movb   $0x1,0x20342e(%rip)        # 604108 <completed.7585>
  400cda:	f3 c3                	repz retq 
  400cdc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400ce0 <frame_dummy>:
  400ce0:	bf 20 3e 60 00       	mov    $0x603e20,%edi
  400ce5:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  400ce9:	75 05                	jne    400cf0 <frame_dummy+0x10>
  400ceb:	eb 93                	jmp    400c80 <register_tm_clones>
  400ced:	0f 1f 00             	nopl   (%rax)
  400cf0:	b8 00 00 00 00       	mov    $0x0,%eax
  400cf5:	48 85 c0             	test   %rax,%rax
  400cf8:	74 f1                	je     400ceb <frame_dummy+0xb>
  400cfa:	55                   	push   %rbp
  400cfb:	48 89 e5             	mov    %rsp,%rbp
  400cfe:	ff d0                	callq  *%rax
  400d00:	5d                   	pop    %rbp
  400d01:	e9 7a ff ff ff       	jmpq   400c80 <register_tm_clones>

0000000000400d06 <generate_matrix>:
}uthread_arg_t;
	
struct timeval tv1;

static void generate_matrix(matrix_t *mat, int val)
{
  400d06:	55                   	push   %rbp
  400d07:	48 89 e5             	mov    %rsp,%rbp
  400d0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  400d0e:	89 75 e4             	mov    %esi,-0x1c(%rbp)

	int i,j;
	mat->rows = SIZE;
  400d11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400d15:	c7 80 00 00 04 00 00 	movl   $0x100,0x40000(%rax)
  400d1c:	01 00 00 
	mat->cols = SIZE;
  400d1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400d23:	c7 80 04 00 04 00 00 	movl   $0x100,0x40004(%rax)
  400d2a:	01 00 00 
	for(i = 0; i < mat->rows;i++)
  400d2d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  400d34:	eb 3d                	jmp    400d73 <generate_matrix+0x6d>
		for( j = 0; j < mat->cols; j++ )
  400d36:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400d3d:	eb 21                	jmp    400d60 <generate_matrix+0x5a>
		{
			mat->m[i][j] = val;
  400d3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400d43:	8b 55 fc             	mov    -0x4(%rbp),%edx
  400d46:	48 63 d2             	movslq %edx,%rdx
  400d49:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  400d4c:	48 63 c9             	movslq %ecx,%rcx
  400d4f:	48 c1 e1 08          	shl    $0x8,%rcx
  400d53:	48 01 d1             	add    %rdx,%rcx
  400d56:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  400d59:	89 14 88             	mov    %edx,(%rax,%rcx,4)

	int i,j;
	mat->rows = SIZE;
	mat->cols = SIZE;
	for(i = 0; i < mat->rows;i++)
		for( j = 0; j < mat->cols; j++ )
  400d5c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400d60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400d64:	8b 80 04 00 04 00    	mov    0x40004(%rax),%eax
  400d6a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  400d6d:	7f d0                	jg     400d3f <generate_matrix+0x39>
{

	int i,j;
	mat->rows = SIZE;
	mat->cols = SIZE;
	for(i = 0; i < mat->rows;i++)
  400d6f:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  400d73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400d77:	8b 80 00 00 04 00    	mov    0x40000(%rax),%eax
  400d7d:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  400d80:	7f b4                	jg     400d36 <generate_matrix+0x30>
		for( j = 0; j < mat->cols; j++ )
		{
			mat->m[i][j] = val;
		}

	return;
  400d82:	90                   	nop
}
  400d83:	5d                   	pop    %rbp
  400d84:	c3                   	retq   

0000000000400d85 <print_matrix>:

static void print_matrix(matrix_t *mat)
{
  400d85:	55                   	push   %rbp
  400d86:	48 89 e5             	mov    %rsp,%rbp
  400d89:	48 83 ec 20          	sub    $0x20,%rsp
  400d8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, j;

	for(i=0;i<SIZE;i++)
  400d91:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  400d98:	eb 4f                	jmp    400de9 <print_matrix+0x64>
	{
		for(j=0;j<SIZE;j++)
  400d9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400da1:	eb 2f                	jmp    400dd2 <print_matrix+0x4d>
			printf(" %d ",mat->m[i][j]);
  400da3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400da7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  400daa:	48 63 d2             	movslq %edx,%rdx
  400dad:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  400db0:	48 63 c9             	movslq %ecx,%rcx
  400db3:	48 c1 e1 08          	shl    $0x8,%rcx
  400db7:	48 01 ca             	add    %rcx,%rdx
  400dba:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  400dbd:	89 c6                	mov    %eax,%esi
  400dbf:	bf 98 2d 40 00       	mov    $0x402d98,%edi
  400dc4:	b8 00 00 00 00       	mov    $0x0,%eax
  400dc9:	e8 f2 fc ff ff       	callq  400ac0 <printf@plt>
{
	int i, j;

	for(i=0;i<SIZE;i++)
	{
		for(j=0;j<SIZE;j++)
  400dce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400dd2:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  400dd9:	7e c8                	jle    400da3 <print_matrix+0x1e>
			printf(" %d ",mat->m[i][j]);
		printf("\n");
  400ddb:	bf 0a 00 00 00       	mov    $0xa,%edi
  400de0:	e8 7b fc ff ff       	callq  400a60 <putchar@plt>

static void print_matrix(matrix_t *mat)
{
	int i, j;

	for(i=0;i<SIZE;i++)
  400de5:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  400de9:	81 7d f8 ff 00 00 00 	cmpl   $0xff,-0x8(%rbp)
  400df0:	7e a8                	jle    400d9a <print_matrix+0x15>
		for(j=0;j<SIZE;j++)
			printf(" %d ",mat->m[i][j]);
		printf("\n");
	}

	return;
  400df2:	90                   	nop
}
  400df3:	c9                   	leaveq 
  400df4:	c3                   	retq   

0000000000400df5 <uthread_mulmat>:

static void * uthread_mulmat(void *p)
{
  400df5:	55                   	push   %rbp
  400df6:	48 89 e5             	mov    %rsp,%rbp
  400df9:	48 83 ec 30          	sub    $0x30,%rsp
  400dfd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int start_col, end_col;
	unsigned int cpuid;

#define ptr ((uthread_arg_t *)p)

	i=0; j= 0; k=0;
  400e01:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
  400e08:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  400e0f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)

	start_row = 0;
  400e16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	end_row = ptr->end_row;
  400e1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400e21:	8b 40 2c             	mov    0x2c(%rax),%eax
  400e24:	89 45 f0             	mov    %eax,-0x10(%rbp)

#ifdef GT_GROUP_SPLIT
	start_col = ptr->start_col;
	end_col = (ptr->start_col + PER_THREAD_ROWS);
#else
	start_col = 0;
  400e27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	end_col = end_row;
  400e2e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400e31:	89 45 f8             	mov    %eax,-0x8(%rbp)
	cpuid = kthread_cpu_map[kthread_apic_id()]->cpuid;
	//fprintf(stderr, "\nThread(id:%d, group:%d, cpu:%d) started",ptr->tid, ptr->gid, cpuid);
#else
	//fprintf(stderr, "\nThread(id:%d, group:%d) started",ptr->tid, ptr->gid);
#endif
	printf("Thread(id:%d, group:%d, cpu:%d) start...\n", ptr->tid, ptr->gid, cpuid);
  400e34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400e38:	8b 50 20             	mov    0x20(%rax),%edx
  400e3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400e3f:	8b 40 1c             	mov    0x1c(%rax),%eax
  400e42:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  400e45:	89 c6                	mov    %eax,%esi
  400e47:	bf a0 2d 40 00       	mov    $0x402da0,%edi
  400e4c:	b8 00 00 00 00       	mov    $0x0,%eax
  400e51:	e8 6a fc ff ff       	callq  400ac0 <printf@plt>
	printf("Row:%d, Col:%d, Start!\n", end_row, end_col);
  400e56:	8b 55 f8             	mov    -0x8(%rbp),%edx
  400e59:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400e5c:	89 c6                	mov    %eax,%esi
  400e5e:	bf ca 2d 40 00       	mov    $0x402dca,%edi
  400e63:	b8 00 00 00 00       	mov    $0x0,%eax
  400e68:	e8 53 fc ff ff       	callq  400ac0 <printf@plt>
	for(i = start_row; i < end_row; i++)
  400e6d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e70:	89 45 e0             	mov    %eax,-0x20(%rbp)
  400e73:	e9 b8 00 00 00       	jmpq   400f30 <uthread_mulmat+0x13b>
		for(j = start_col; j < end_col; j++)
  400e78:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400e7b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  400e7e:	e9 9d 00 00 00       	jmpq   400f20 <uthread_mulmat+0x12b>
			for(k = 0; k < end_col; k++) {// ** Change dimension here.
  400e83:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400e8a:	e9 81 00 00 00       	jmpq   400f10 <uthread_mulmat+0x11b>
				ptr->_C->m[i][j] += ptr->_A->m[i][k] * ptr->_B->m[k][j];
  400e8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400e93:	48 8b 40 10          	mov    0x10(%rax),%rax
  400e97:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400e9b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  400e9f:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  400ea2:	48 63 c9             	movslq %ecx,%rcx
  400ea5:	8b 75 e0             	mov    -0x20(%rbp),%esi
  400ea8:	48 63 f6             	movslq %esi,%rsi
  400eab:	48 c1 e6 08          	shl    $0x8,%rsi
  400eaf:	48 01 f1             	add    %rsi,%rcx
  400eb2:	8b 0c 8a             	mov    (%rdx,%rcx,4),%ecx
  400eb5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400eb9:	48 8b 12             	mov    (%rdx),%rdx
  400ebc:	8b 75 e8             	mov    -0x18(%rbp),%esi
  400ebf:	48 63 f6             	movslq %esi,%rsi
  400ec2:	8b 7d e0             	mov    -0x20(%rbp),%edi
  400ec5:	48 63 ff             	movslq %edi,%rdi
  400ec8:	48 c1 e7 08          	shl    $0x8,%rdi
  400ecc:	48 01 fe             	add    %rdi,%rsi
  400ecf:	8b 34 b2             	mov    (%rdx,%rsi,4),%esi
  400ed2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400ed6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  400eda:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  400edd:	48 63 ff             	movslq %edi,%rdi
  400ee0:	44 8b 45 e8          	mov    -0x18(%rbp),%r8d
  400ee4:	4d 63 c0             	movslq %r8d,%r8
  400ee7:	49 c1 e0 08          	shl    $0x8,%r8
  400eeb:	4c 01 c7             	add    %r8,%rdi
  400eee:	8b 14 ba             	mov    (%rdx,%rdi,4),%edx
  400ef1:	0f af d6             	imul   %esi,%edx
  400ef4:	01 d1                	add    %edx,%ecx
  400ef6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  400ef9:	48 63 d2             	movslq %edx,%rdx
  400efc:	8b 75 e0             	mov    -0x20(%rbp),%esi
  400eff:	48 63 f6             	movslq %esi,%rsi
  400f02:	48 c1 e6 08          	shl    $0x8,%rsi
  400f06:	48 01 f2             	add    %rsi,%rdx
  400f09:	89 0c 90             	mov    %ecx,(%rax,%rdx,4)
#endif
	printf("Thread(id:%d, group:%d, cpu:%d) start...\n", ptr->tid, ptr->gid, cpuid);
	printf("Row:%d, Col:%d, Start!\n", end_row, end_col);
	for(i = start_row; i < end_row; i++)
		for(j = start_col; j < end_col; j++)
			for(k = 0; k < end_col; k++) {// ** Change dimension here.
  400f0c:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  400f10:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400f13:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  400f16:	0f 8c 73 ff ff ff    	jl     400e8f <uthread_mulmat+0x9a>
	//fprintf(stderr, "\nThread(id:%d, group:%d) started",ptr->tid, ptr->gid);
#endif
	printf("Thread(id:%d, group:%d, cpu:%d) start...\n", ptr->tid, ptr->gid, cpuid);
	printf("Row:%d, Col:%d, Start!\n", end_row, end_col);
	for(i = start_row; i < end_row; i++)
		for(j = start_col; j < end_col; j++)
  400f1c:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  400f20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  400f23:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  400f26:	0f 8c 57 ff ff ff    	jl     400e83 <uthread_mulmat+0x8e>
#else
	//fprintf(stderr, "\nThread(id:%d, group:%d) started",ptr->tid, ptr->gid);
#endif
	printf("Thread(id:%d, group:%d, cpu:%d) start...\n", ptr->tid, ptr->gid, cpuid);
	printf("Row:%d, Col:%d, Start!\n", end_row, end_col);
	for(i = start_row; i < end_row; i++)
  400f2c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  400f30:	8b 45 e0             	mov    -0x20(%rbp),%eax
  400f33:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400f36:	0f 8c 3c ff ff ff    	jl     400e78 <uthread_mulmat+0x83>
	//fprintf(stderr, "\nThread(id:%d, group:%d) finished (TIME : %lu s and %lu us)",
	//		ptr->tid, ptr->gid, (tv2.tv_sec - tv1.tv_sec), (tv2.tv_usec - tv1.tv_usec));
#endif

#undef ptr
	return 0;
  400f3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  400f41:	c9                   	leaveq 
  400f42:	c3                   	retq   

0000000000400f43 <resize>:

// 	return;
// }

void resize(int thread_id, int* size) // ** Size Modification
{
  400f43:	55                   	push   %rbp
  400f44:	48 89 e5             	mov    %rsp,%rbp
  400f47:	48 83 ec 10          	sub    $0x10,%rsp
  400f4b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  400f4e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if (thread_id < 32)
  400f52:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  400f56:	7f 0c                	jg     400f64 <resize+0x21>
	{
		*size = 32;
  400f58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f5c:	c7 00 20 00 00 00    	movl   $0x20,(%rax)
	}
	else
	{
		printf(stderr, "Threads exceeds!\n");
	}
}
  400f62:	eb 4f                	jmp    400fb3 <resize+0x70>
{
	if (thread_id < 32)
	{
		*size = 32;
	}
	else if (thread_id < 64)
  400f64:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  400f68:	7f 0c                	jg     400f76 <resize+0x33>
	{
		*size = 64;
  400f6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f6e:	c7 00 40 00 00 00    	movl   $0x40,(%rax)
	}
	else
	{
		printf(stderr, "Threads exceeds!\n");
	}
}
  400f74:	eb 3d                	jmp    400fb3 <resize+0x70>
	}
	else if (thread_id < 64)
	{
		*size = 64;
	}
	else if (thread_id < 96)
  400f76:	83 7d fc 5f          	cmpl   $0x5f,-0x4(%rbp)
  400f7a:	7f 0c                	jg     400f88 <resize+0x45>
	{
		*size = 128;
  400f7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f80:	c7 00 80 00 00 00    	movl   $0x80,(%rax)
	}
	else
	{
		printf(stderr, "Threads exceeds!\n");
	}
}
  400f86:	eb 2b                	jmp    400fb3 <resize+0x70>
	}
	else if (thread_id < 96)
	{
		*size = 128;
	}
	else if (thread_id < 128)
  400f88:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  400f8c:	7f 0c                	jg     400f9a <resize+0x57>
	{
		*size = 256;
  400f8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f92:	c7 00 00 01 00 00    	movl   $0x100,(%rax)
	}
	else
	{
		printf(stderr, "Threads exceeds!\n");
	}
}
  400f98:	eb 19                	jmp    400fb3 <resize+0x70>
	{
		*size = 256;
	}
	else
	{
		printf(stderr, "Threads exceeds!\n");
  400f9a:	48 8b 05 5f 31 20 00 	mov    0x20315f(%rip),%rax        # 604100 <__TMC_END__>
  400fa1:	be e2 2d 40 00       	mov    $0x402de2,%esi
  400fa6:	48 89 c7             	mov    %rax,%rdi
  400fa9:	b8 00 00 00 00       	mov    $0x0,%eax
  400fae:	e8 0d fb ff ff       	callq  400ac0 <printf@plt>
	}
}
  400fb3:	90                   	nop
  400fb4:	c9                   	leaveq 
  400fb5:	c3                   	retq   

0000000000400fb6 <main>:

uthread_arg_t uargs[NUM_THREADS];
uthread_t utids[NUM_THREADS];

int main()
{
  400fb6:	55                   	push   %rbp
  400fb7:	48 89 e5             	mov    %rsp,%rbp
  400fba:	48 81 ec 50 00 0c 00 	sub    $0xc0050,%rsp
  400fc1:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  400fc8:	00 00 
  400fca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  400fce:	31 c0                	xor    %eax,%eax
	uthread_arg_t *uarg;// * Point to lists of u_arg
	int inx;            // * Thread_id
	matrix_t A, B;
	generate_matrix(&A, 1);
  400fd0:	48 8d 85 c0 ff f3 ff 	lea    -0xc0040(%rbp),%rax
  400fd7:	be 01 00 00 00       	mov    $0x1,%esi
  400fdc:	48 89 c7             	mov    %rax,%rdi
  400fdf:	e8 22 fd ff ff       	callq  400d06 <generate_matrix>
	generate_matrix(&B, 1);
  400fe4:	48 8d 85 d0 ff f7 ff 	lea    -0x80030(%rbp),%rax
  400feb:	be 01 00 00 00       	mov    $0x1,%esi
  400ff0:	48 89 c7             	mov    %rax,%rdi
  400ff3:	e8 0e fd ff ff       	callq  400d06 <generate_matrix>

	gtthread_app_init();
  400ff8:	b8 00 00 00 00       	mov    $0x0,%eax
  400ffd:	e8 a4 06 00 00       	callq  4016a6 <gtthread_app_init>
	printf("Initialize complete\n");
  401002:	bf f4 2d 40 00       	mov    $0x402df4,%edi
  401007:	e8 74 fa ff ff       	callq  400a80 <puts@plt>

	for(inx=0; inx<64; inx++)  // NUM_THREADS
  40100c:	c7 85 b4 ff f3 ff 00 	movl   $0x0,-0xc004c(%rbp)
  401013:	00 00 00 
  401016:	e9 79 01 00 00       	jmpq   401194 <main+0x1de>
	{
		printf("Creating Thread: %d\n", inx);
  40101b:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  401021:	89 c6                	mov    %eax,%esi
  401023:	bf 08 2e 40 00       	mov    $0x402e08,%edi
  401028:	b8 00 00 00 00       	mov    $0x0,%eax
  40102d:	e8 8e fa ff ff       	callq  400ac0 <printf@plt>
		matrix_t C;
		int size;			// ** Matrix Size
		
		generate_matrix(&C, 0);
  401032:	48 8d 85 e0 ff fb ff 	lea    -0x40020(%rbp),%rax
  401039:	be 00 00 00 00       	mov    $0x0,%esi
  40103e:	48 89 c7             	mov    %rax,%rdi
  401041:	e8 c0 fc ff ff       	callq  400d06 <generate_matrix>
		
		uarg = &uargs[inx];
  401046:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  40104c:	48 98                	cltq   
  40104e:	48 c1 e0 06          	shl    $0x6,%rax
  401052:	48 05 40 41 60 00    	add    $0x604140,%rax
  401058:	48 89 85 b8 ff f3 ff 	mov    %rax,-0xc0048(%rbp)
		uarg->_A = &A;
  40105f:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401066:	48 8d 95 c0 ff f3 ff 	lea    -0xc0040(%rbp),%rdx
  40106d:	48 89 10             	mov    %rdx,(%rax)
		uarg->_B = &B;
  401070:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401077:	48 8d 95 d0 ff f7 ff 	lea    -0x80030(%rbp),%rdx
  40107e:	48 89 50 08          	mov    %rdx,0x8(%rax)
		uarg->_C = &C;
  401082:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401089:	48 8d 95 e0 ff fb ff 	lea    -0x40020(%rbp),%rdx
  401090:	48 89 50 10          	mov    %rdx,0x10(%rax)

		uarg->tid = inx;
  401094:	8b 95 b4 ff f3 ff    	mov    -0xc004c(%rbp),%edx
  40109a:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  4010a1:	89 50 1c             	mov    %edx,0x1c(%rax)

		uarg->gid = (inx % NUM_GROUPS); 
  4010a4:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  4010aa:	99                   	cltd   
  4010ab:	c1 ea 1f             	shr    $0x1f,%edx
  4010ae:	01 d0                	add    %edx,%eax
  4010b0:	83 e0 01             	and    $0x1,%eax
  4010b3:	29 d0                	sub    %edx,%eax
  4010b5:	89 c2                	mov    %eax,%edx
  4010b7:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  4010be:	89 50 20             	mov    %edx,0x20(%rax)
		resize(inx, &size);
  4010c1:	48 8d 95 b0 ff f3 ff 	lea    -0xc0050(%rbp),%rdx
  4010c8:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  4010ce:	48 89 d6             	mov    %rdx,%rsi
  4010d1:	89 c7                	mov    %eax,%edi
  4010d3:	e8 6b fe ff ff       	callq  400f43 <resize>

		// * NOt used 
		// uarg->start_row = (inx * PER_THREAD_ROWS);
		// ** New added
		uarg->start_row = 0;
  4010d8:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  4010df:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
		uarg->end_row = size;
  4010e6:	8b 95 b0 ff f3 ff    	mov    -0xc0050(%rbp),%edx
  4010ec:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  4010f3:	89 50 2c             	mov    %edx,0x2c(%rax)
		uarg->start_col = 0;
  4010f6:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  4010fd:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
		uarg->end_col = size;
  401104:	8b 95 b0 ff f3 ff    	mov    -0xc0050(%rbp),%edx
  40110a:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401111:	89 50 30             	mov    %edx,0x30(%rax)

		uarg->sched_mode = CREDIT_SCHED;
  401114:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  40111b:	c7 40 38 16 00 00 00 	movl   $0x16,0x38(%rax)
		uarg->credits = credits_init(inx);
  401122:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  401128:	89 c7                	mov    %eax,%edi
  40112a:	e8 d1 1a 00 00       	callq  402c00 <credits_init>
  40112f:	89 c2                	mov    %eax,%edx
  401131:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401138:	89 50 34             	mov    %edx,0x34(%rax)

		uthread_create(&utids[inx], uthread_mulmat, uarg, uarg->gid, uarg->sched_mode, uarg->credits);
  40113b:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401142:	8b 70 34             	mov    0x34(%rax),%esi
  401145:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  40114c:	8b 48 38             	mov    0x38(%rax),%ecx
  40114f:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401156:	8b 50 20             	mov    0x20(%rax),%edx
  401159:	8b 85 b4 ff f3 ff    	mov    -0xc004c(%rbp),%eax
  40115f:	48 98                	cltq   
  401161:	48 c1 e0 02          	shl    $0x2,%rax
  401165:	48 8d b8 40 61 60 00 	lea    0x606140(%rax),%rdi
  40116c:	48 8b 85 b8 ff f3 ff 	mov    -0xc0048(%rbp),%rax
  401173:	41 89 f1             	mov    %esi,%r9d
  401176:	41 89 c8             	mov    %ecx,%r8d
  401179:	89 d1                	mov    %edx,%ecx
  40117b:	48 89 c2             	mov    %rax,%rdx
  40117e:	be f5 0d 40 00       	mov    $0x400df5,%esi
  401183:	b8 00 00 00 00       	mov    $0x0,%eax
  401188:	e8 46 0f 00 00       	callq  4020d3 <uthread_create>
	generate_matrix(&B, 1);

	gtthread_app_init();
	printf("Initialize complete\n");

	for(inx=0; inx<64; inx++)  // NUM_THREADS
  40118d:	83 85 b4 ff f3 ff 01 	addl   $0x1,-0xc004c(%rbp)
  401194:	83 bd b4 ff f3 ff 3f 	cmpl   $0x3f,-0xc004c(%rbp)
  40119b:	0f 8e 7a fe ff ff    	jle    40101b <main+0x65>
		uarg->sched_mode = CREDIT_SCHED;
		uarg->credits = credits_init(inx);

		uthread_create(&utids[inx], uthread_mulmat, uarg, uarg->gid, uarg->sched_mode, uarg->credits);
	}
	gtthread_app_exit();
  4011a1:	b8 00 00 00 00       	mov    $0x0,%eax
  4011a6:	e8 95 06 00 00       	callq  401840 <gtthread_app_exit>

	// print_matrix(&C);
	// fprintf(stderr, "********************************");
	return(0);
  4011ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4011b0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  4011b4:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  4011bb:	00 00 
  4011bd:	74 05                	je     4011c4 <main+0x20e>
  4011bf:	e8 ec f8 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  4011c4:	c9                   	leaveq 
  4011c5:	c3                   	retq   

00000000004011c6 <kthread_apic_id>:
extern int kthread_create(kthread_t *tid, int (*start_fun)(void *), void *arg);

/**********************************************************************/
/* apic-id of the cpu on which kthread is running (kthread_cpu_map) */
static inline unsigned char kthread_apic_id(void)
{
  4011c6:	55                   	push   %rbp
  4011c7:	48 89 e5             	mov    %rsp,%rbp
  4011ca:	53                   	push   %rbx
 * EBX[31:24] Bits 24-31 (8 bits) return the 8-bit unique.
 * Initial APIC ID for the processor this code is running on.*/
#define INITIAL_APIC_ID_BITS  0xFF000000


	unsigned int Regebx = 0;
  4011cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	__asm__ __volatile__ (
  4011d2:	b8 01 00 00 00       	mov    $0x1,%eax
  4011d7:	0f a2                	cpuid  
  4011d9:	89 de                	mov    %ebx,%esi
  4011db:	89 75 f4             	mov    %esi,-0xc(%rbp)
		"movl $1, %%eax\n\t"
		"cpuid"
		:"=b" (Regebx)
		: :"%eax","%ecx","%edx");

	return((unsigned char)((Regebx & INITIAL_APIC_ID_BITS) >> 24));
  4011de:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4011e1:	c1 e8 18             	shr    $0x18,%eax
#undef INITIAL_APIC_ID_BITS
}
  4011e4:	5b                   	pop    %rbx
  4011e5:	5d                   	pop    %rbp
  4011e6:	c3                   	retq   

00000000004011e7 <MALLOC_SAFE>:


/**********************************************************************/
/* Thread-safe malloc */
static inline void *MALLOC_SAFE(unsigned int size)
{
  4011e7:	55                   	push   %rbp
  4011e8:	48 89 e5             	mov    %rsp,%rbp
  4011eb:	48 83 ec 20          	sub    $0x20,%rsp
  4011ef:	89 7d ec             	mov    %edi,-0x14(%rbp)
	void *__ptr;
	gt_spin_lock(&(ksched_shared_info.__malloc_lock));
  4011f2:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  4011f7:	e8 a6 19 00 00       	callq  402ba2 <gt_spin_lock>
	__ptr = malloc(size);
  4011fc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4011ff:	48 89 c7             	mov    %rax,%rdi
  401202:	e8 69 f9 ff ff       	callq  400b70 <malloc@plt>
  401207:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	gt_spin_unlock(&(ksched_shared_info.__malloc_lock));
  40120b:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  401210:	e8 ba 19 00 00       	callq  402bcf <gt_spin_unlock>
	return(__ptr);
  401215:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401219:	c9                   	leaveq 
  40121a:	c3                   	retq   

000000000040121b <MALLOCZ_SAFE>:

/* Zeroes out allocated bytes */
static inline void *MALLOCZ_SAFE(unsigned int size)
{
  40121b:	55                   	push   %rbp
  40121c:	48 89 e5             	mov    %rsp,%rbp
  40121f:	48 83 ec 20          	sub    $0x20,%rsp
  401223:	89 7d ec             	mov    %edi,-0x14(%rbp)
	void *__ptr;
	gt_spin_lock(&(ksched_shared_info.__malloc_lock));
  401226:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  40122b:	e8 72 19 00 00       	callq  402ba2 <gt_spin_lock>
	__ptr = calloc(1, size);
  401230:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401233:	48 89 c6             	mov    %rax,%rsi
  401236:	bf 01 00 00 00       	mov    $0x1,%edi
  40123b:	e8 f0 f8 ff ff       	callq  400b30 <calloc@plt>
  401240:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	gt_spin_unlock(&(ksched_shared_info.__malloc_lock));
  401244:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  401249:	e8 81 19 00 00       	callq  402bcf <gt_spin_unlock>
	return(__ptr);
  40124e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401252:	c9                   	leaveq 
  401253:	c3                   	retq   

0000000000401254 <kthread_create>:
static void gtthread_app_start(void* arg);  // * why void??

/**********************************************************************/
/* kthread creation */
int kthread_create(kthread_t *tid, int (*kthread_start_func)(void *), void *arg)
{
  401254:	55                   	push   %rbp
  401255:	48 89 e5             	mov    %rsp,%rbp
  401258:	48 83 ec 30          	sub    $0x30,%rsp
  40125c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401260:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401264:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int retval = 0;
  401268:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	void **stack;
	int stacksize;

	stacksize = KTHREAD_DEFAULT_SSIZE;
  40126f:	c7 45 f4 00 00 04 00 	movl   $0x40000,-0xc(%rbp)

	/* Create the new thread's stack */
	if(!(stack = (void **)MALLOC_SAFE(stacksize)))
  401276:	8b 45 f4             	mov    -0xc(%rbp),%eax
  401279:	89 c7                	mov    %eax,%edi
  40127b:	e8 67 ff ff ff       	callq  4011e7 <MALLOC_SAFE>
  401280:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  401284:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  401289:	75 11                	jne    40129c <kthread_create+0x48>
	{
		perror("No memory !!");
  40128b:	bf 20 2e 40 00       	mov    $0x402e20,%edi
  401290:	e8 fb f8 ff ff       	callq  400b90 <perror@plt>
		return -1;
  401295:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40129a:	eb 46                	jmp    4012e2 <kthread_create+0x8e>
	}
	stack = (void*)((char*)stack + stacksize);
  40129c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40129f:	48 98                	cltq   
  4012a1:	48 01 45 f8          	add    %rax,-0x8(%rbp)

	retval = clone(kthread_start_func, stack, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | SIGCHLD, arg);
  4012a5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4012a9:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  4012ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4012b1:	48 89 d1             	mov    %rdx,%rcx
  4012b4:	ba 11 0f 00 00       	mov    $0xf11,%edx
  4012b9:	48 89 c7             	mov    %rax,%rdi
  4012bc:	b8 00 00 00 00       	mov    $0x0,%eax
  4012c1:	e8 da f7 ff ff       	callq  400aa0 <clone@plt>
  4012c6:	89 45 f0             	mov    %eax,-0x10(%rbp)
	
	if(retval > 0)
  4012c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  4012cd:	7e 0e                	jle    4012dd <kthread_create+0x89>
	{
		*tid = retval;
  4012cf:	8b 55 f0             	mov    -0x10(%rbp),%edx
  4012d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4012d6:	89 10                	mov    %edx,(%rax)
		return retval;
  4012d8:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4012db:	eb 05                	jmp    4012e2 <kthread_create+0x8e>
	}
	
	return -1;
  4012dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  4012e2:	c9                   	leaveq 
  4012e3:	c3                   	retq   

00000000004012e4 <kthread_handler>:

static int kthread_handler(void *arg)
{
  4012e4:	55                   	push   %rbp
  4012e5:	48 89 e5             	mov    %rsp,%rbp
  4012e8:	48 83 ec 10          	sub    $0x10,%rsp
  4012ec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#define k_ctx ((kthread_context_t *)arg)

#if 0
	printf("Thread to be scheduled on cpu\n");
#endif
	kthread_init(k_ctx);
  4012f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4012f4:	48 89 c7             	mov    %rax,%rdi
  4012f7:	e8 16 00 00 00       	callq  401312 <kthread_init>
#if 0
	printf("\nThread (tid : %u, pid : %u,  cpu : %d, cpu-apic-id %d) ready to run !!\n\n", 
		k_ctx->tid, k_ctx->pid, k_ctx->cpuid, k_ctx->cpu_apic_id);
#endif

	k_ctx->kthread_app_func(NULL);
  4012fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401300:	48 8b 40 18          	mov    0x18(%rax),%rax
  401304:	bf 00 00 00 00       	mov    $0x0,%edi
  401309:	ff d0                	callq  *%rax
#undef k_ctx
	// free(arg);
	return 0;
  40130b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401310:	c9                   	leaveq 
  401311:	c3                   	retq   

0000000000401312 <kthread_init>:

static void kthread_init(kthread_context_t *k_ctx)
{
  401312:	55                   	push   %rbp
  401313:	48 89 e5             	mov    %rsp,%rbp
  401316:	48 83 ec 20          	sub    $0x20,%rsp
  40131a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40131e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401325:	00 00 
  401327:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40132b:	31 c0                	xor    %eax,%eax
	int cpu_affinity_mask, cur_cpu_apic_id;

	/* cpuid and kthread_app_func are set by the application 
	 * over kthread (eg. gtthread). */

	k_ctx->pid = syscall(SYS_getpid);
  40132d:	bf 27 00 00 00       	mov    $0x27,%edi
  401332:	b8 00 00 00 00       	mov    $0x0,%eax
  401337:	e8 14 f8 ff ff       	callq  400b50 <syscall@plt>
  40133c:	89 c2                	mov    %eax,%edx
  40133e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401342:	89 50 08             	mov    %edx,0x8(%rax)
	k_ctx->tid = syscall(SYS_gettid);
  401345:	bf ba 00 00 00       	mov    $0xba,%edi
  40134a:	b8 00 00 00 00       	mov    $0x0,%eax
  40134f:	e8 fc f7 ff ff       	callq  400b50 <syscall@plt>
  401354:	89 c2                	mov    %eax,%edx
  401356:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40135a:	89 50 0c             	mov    %edx,0xc(%rax)

	/* For priority co-scheduling */
	k_ctx->kthread_sched_timer = ksched_priority;
  40135d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401361:	48 c7 40 20 60 15 40 	movq   $0x401560,0x20(%rax)
  401368:	00 
	k_ctx->kthread_sched_relay = ksched_cosched;
  401369:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40136d:	48 c7 40 28 1a 15 40 	movq   $0x40151a,0x28(%rax)
  401374:	00 

	/* XXX: kthread runqueue balancing (TBD) */
	k_ctx->kthread_runqueue_balance = NULL;
  401375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401379:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  401380:	00 

	/* Initialize kthread runqueue */

	kthread_init_runqueue(&(k_ctx->krunqueue));
  401381:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401385:	48 05 00 01 00 00    	add    $0x100,%rax
  40138b:	48 89 c7             	mov    %rax,%rdi
  40138e:	e8 6e 13 00 00       	callq  402701 <kthread_init_runqueue>

	cpu_affinity_mask = (1 << k_ctx->cpuid);
  401393:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401397:	8b 00                	mov    (%rax),%eax
  401399:	ba 01 00 00 00       	mov    $0x1,%edx
  40139e:	89 c1                	mov    %eax,%ecx
  4013a0:	d3 e2                	shl    %cl,%edx
  4013a2:	89 d0                	mov    %edx,%eax
  4013a4:	89 45 f4             	mov    %eax,-0xc(%rbp)
	sched_setaffinity(k_ctx->tid,sizeof(unsigned long),&cpu_affinity_mask);
  4013a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4013ab:	8b 40 0c             	mov    0xc(%rax),%eax
  4013ae:	89 c1                	mov    %eax,%ecx
  4013b0:	48 8d 45 f4          	lea    -0xc(%rbp),%rax
  4013b4:	48 89 c2             	mov    %rax,%rdx
  4013b7:	be 08 00 00 00       	mov    $0x8,%esi
  4013bc:	89 cf                	mov    %ecx,%edi
  4013be:	e8 3d f7 ff ff       	callq  400b00 <sched_setaffinity@plt>

	sched_yield();
  4013c3:	e8 48 f7 ff ff       	callq  400b10 <sched_yield@plt>

	/* Scheduled on target cpu */
	k_ctx->cpu_apic_id = kthread_apic_id();
  4013c8:	e8 f9 fd ff ff       	callq  4011c6 <kthread_apic_id>
  4013cd:	0f b6 d0             	movzbl %al,%edx
  4013d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4013d4:	89 50 04             	mov    %edx,0x4(%rax)

	kthread_cpu_map[k_ctx->cpu_apic_id] = k_ctx;
  4013d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4013db:	8b 40 04             	mov    0x4(%rax),%eax
  4013de:	89 c2                	mov    %eax,%edx
  4013e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4013e4:	48 89 04 d5 c0 63 60 	mov    %rax,0x6063c0(,%rdx,8)
  4013eb:	00 

	return;
  4013ec:	90                   	nop
}
  4013ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4013f1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4013f8:	00 00 
  4013fa:	74 05                	je     401401 <kthread_init+0xef>
  4013fc:	e8 af f6 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  401401:	c9                   	leaveq 
  401402:	c3                   	retq   

0000000000401403 <kthread_exit>:

static inline void kthread_exit()
{
  401403:	55                   	push   %rbp
  401404:	48 89 e5             	mov    %rsp,%rbp
	return;
  401407:	90                   	nop
}
  401408:	5d                   	pop    %rbp
  401409:	c3                   	retq   

000000000040140a <ksched_info_init>:
/**********************************************************************/
/* kthread schedule */

/* Initialize the ksched_shared_info */
static inline void ksched_info_init(ksched_shared_info_t *ksched_info)
{
  40140a:	55                   	push   %rbp
  40140b:	48 89 e5             	mov    %rsp,%rbp
  40140e:	48 83 ec 10          	sub    $0x10,%rsp
  401412:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	gt_spinlock_init(&(ksched_info->ksched_lock));
  401416:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40141a:	48 83 c0 50          	add    $0x50,%rax
  40141e:	48 89 c7             	mov    %rax,%rdi
  401421:	e8 f9 16 00 00       	callq  402b1f <gt_spinlock_init>
	gt_spinlock_init(&(ksched_info->uthread_init_lock));
  401426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40142a:	48 83 c0 58          	add    $0x58,%rax
  40142e:	48 89 c7             	mov    %rax,%rdi
  401431:	e8 e9 16 00 00       	callq  402b1f <gt_spinlock_init>
	gt_spinlock_init(&(ksched_info->__malloc_lock));
  401436:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40143a:	48 83 c0 60          	add    $0x60,%rax
  40143e:	48 89 c7             	mov    %rax,%rdi
  401441:	e8 d9 16 00 00       	callq  402b1f <gt_spinlock_init>
	return;
  401446:	90                   	nop
}
  401447:	c9                   	leaveq 
  401448:	c3                   	retq   

0000000000401449 <KTHREAD_PRINT_SCHED_DEBUGINFO>:

static inline void KTHREAD_PRINT_SCHED_DEBUGINFO(kthread_context_t *k_ctx, char *str)
{
  401449:	55                   	push   %rbp
  40144a:	48 89 e5             	mov    %rsp,%rbp
  40144d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  401451:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	/* Thread-safe ?? */
	gettimeofday(&tv, NULL);
	printf("\n%s SIGNAL (cpu : %d, apic_id : %d) (ts : %d)\n",
		str, k_ctx->cpuid, k_ctx->cpu_apic_id, tv.tv_usec);
#endif
	return;
  401455:	90                   	nop
}
  401456:	5d                   	pop    %rbp
  401457:	c3                   	retq   

0000000000401458 <ksched_find_target>:

extern kthread_runqueue_t *ksched_find_target(uthread_struct_t *u_obj)
{
  401458:	55                   	push   %rbp
  401459:	48 89 e5             	mov    %rsp,%rbp
  40145c:	48 83 ec 20          	sub    $0x20,%rsp
  401460:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	ksched_shared_info_t *ksched_info;
	unsigned int target_cpu, u_gid;

	ksched_info = &ksched_shared_info;
  401464:	48 c7 45 f8 40 63 60 	movq   $0x606340,-0x8(%rbp)
  40146b:	00 
	u_gid = u_obj->uthread_gid;
  40146c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401470:	8b 40 14             	mov    0x14(%rax),%eax
  401473:	89 45 f4             	mov    %eax,-0xc(%rbp)

	target_cpu = ksched_info->last_ugroup_kthread[u_gid];
  401476:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40147a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40147d:	48 83 c2 08          	add    $0x8,%rdx
  401481:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  401485:	0f b7 c0             	movzwl %ax,%eax
  401488:	89 45 f0             	mov    %eax,-0x10(%rbp)
	
	do
	{
		/* How dumb to assume there is atleast one cpu (haha) !! :-D */
		target_cpu = ((target_cpu + 1) % GT_MAX_CORES);
  40148b:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40148e:	83 c0 01             	add    $0x1,%eax
  401491:	83 e0 0f             	and    $0xf,%eax
  401494:	89 45 f0             	mov    %eax,-0x10(%rbp)
	} while(!kthread_cpu_map[target_cpu]);
  401497:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40149a:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  4014a1:	00 
  4014a2:	48 85 c0             	test   %rax,%rax
  4014a5:	74 e4                	je     40148b <ksched_find_target+0x33>

	gt_spin_lock(&(ksched_info->ksched_lock));
  4014a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4014ab:	48 83 c0 50          	add    $0x50,%rax
  4014af:	48 89 c7             	mov    %rax,%rdi
  4014b2:	e8 eb 16 00 00       	callq  402ba2 <gt_spin_lock>
	ksched_info->last_ugroup_kthread[u_gid] = target_cpu;
  4014b7:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4014ba:	89 c1                	mov    %eax,%ecx
  4014bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4014c0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  4014c3:	48 83 c2 08          	add    $0x8,%rdx
  4014c7:	66 89 0c 50          	mov    %cx,(%rax,%rdx,2)
	gt_spin_unlock(&(ksched_info->ksched_lock));
  4014cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4014cf:	48 83 c0 50          	add    $0x50,%rax
  4014d3:	48 89 c7             	mov    %rax,%rdi
  4014d6:	e8 f4 16 00 00       	callq  402bcf <gt_spin_unlock>

	u_obj->cpu_id = kthread_cpu_map[target_cpu]->cpuid;
  4014db:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4014de:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  4014e5:	00 
  4014e6:	8b 00                	mov    (%rax),%eax
  4014e8:	89 c2                	mov    %eax,%edx
  4014ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4014ee:	89 50 08             	mov    %edx,0x8(%rax)
	u_obj->last_cpu_id = kthread_cpu_map[target_cpu]->cpuid;
  4014f1:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4014f4:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  4014fb:	00 
  4014fc:	8b 00                	mov    (%rax),%eax
  4014fe:	89 c2                	mov    %eax,%edx
  401500:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401504:	89 50 0c             	mov    %edx,0xc(%rax)

#if 0
	printf("Target uthread (id:%d, group:%d) : cpu(%d)\n", u_obj->uthread_tid, u_obj->uthread_gid, kthread_cpu_map[target_cpu]->cpuid);
#endif

	return(&(kthread_cpu_map[target_cpu]->krunqueue));
  401507:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40150a:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401511:	00 
  401512:	48 05 00 01 00 00    	add    $0x100,%rax
}
  401518:	c9                   	leaveq 
  401519:	c3                   	retq   

000000000040151a <ksched_cosched>:

static void ksched_cosched(int signal)
{
  40151a:	55                   	push   %rbp
  40151b:	48 89 e5             	mov    %rsp,%rbp
  40151e:	48 83 ec 20          	sub    $0x20,%rsp
  401522:	89 7d ec             	mov    %edi,-0x14(%rbp)

	/* This virtual processor (thread) was not
	 * picked by kernel for vtalrm signal.
	 * USR1 signal has been relayed to it. */

	cur_k_ctx = kthread_cpu_map[kthread_apic_id()];
  401525:	e8 9c fc ff ff       	callq  4011c6 <kthread_apic_id>
  40152a:	0f b6 c0             	movzbl %al,%eax
  40152d:	48 98                	cltq   
  40152f:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401536:	00 
  401537:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	KTHREAD_PRINT_SCHED_DEBUGINFO(cur_k_ctx, "RELAY(USR)");
  40153b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40153f:	be 2d 2e 40 00       	mov    $0x402e2d,%esi
  401544:	48 89 c7             	mov    %rax,%rdi
  401547:	e8 fd fe ff ff       	callq  401449 <KTHREAD_PRINT_SCHED_DEBUGINFO>

#ifdef CO_SCHED
	uthread_schedule(&sched_find_best_uthread_group);
#else
	uthread_schedule(&sched_find_best_uthread);
  40154c:	bf 7d 27 40 00       	mov    $0x40277d,%edi
  401551:	e8 35 06 00 00       	callq  401b8b <uthread_schedule>
#endif

	// kthread_unblock_signal(SIGVTALRM);
	// kthread_unblock_signal(SIGUSR1);
	return;
  401556:	90                   	nop
}
  401557:	c9                   	leaveq 
  401558:	c3                   	retq   

0000000000401559 <ksched_announce_cosched_group>:

static void ksched_announce_cosched_group()
{
  401559:	55                   	push   %rbp
  40155a:	48 89 e5             	mov    %rsp,%rbp
	/* Set the current running uthread_group  */
	return;
  40155d:	90                   	nop
}
  40155e:	5d                   	pop    %rbp
  40155f:	c3                   	retq   

0000000000401560 <ksched_priority>:

static void ksched_priority(int signo)
{
  401560:	55                   	push   %rbp
  401561:	48 89 e5             	mov    %rsp,%rbp
  401564:	48 83 ec 30          	sub    $0x30,%rsp
  401568:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int inx;
	// *Block
	//kthread_block_signal(SIGVTALRM);
	//kthread_block_signal(SIGUSR1);

	ksched_announce_cosched_group();
  40156b:	b8 00 00 00 00       	mov    $0x0,%eax
  401570:	e8 e4 ff ff ff       	callq  401559 <ksched_announce_cosched_group>

	cur_k_ctx = kthread_cpu_map[kthread_apic_id()];
  401575:	e8 4c fc ff ff       	callq  4011c6 <kthread_apic_id>
  40157a:	0f b6 c0             	movzbl %al,%eax
  40157d:	48 98                	cltq   
  40157f:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401586:	00 
  401587:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	KTHREAD_PRINT_SCHED_DEBUGINFO(cur_k_ctx, "VTALRM");
  40158b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40158f:	be 38 2e 40 00       	mov    $0x402e38,%esi
  401594:	48 89 c7             	mov    %rax,%rdi
  401597:	e8 ad fe ff ff       	callq  401449 <KTHREAD_PRINT_SCHED_DEBUGINFO>

	/* Relay the signal to all other virtual processors(kthreads) */
	for(inx=0; inx<GT_MAX_KTHREADS; inx++)
  40159c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  4015a3:	eb 54                	jmp    4015f9 <ksched_priority+0x99>
	{
		/* XXX: We can avoid the last check (tmp to cur) by
		 * temporarily marking cur as DONE. But chuck it !! */
		if((tmp_k_ctx = kthread_cpu_map[inx]) && (tmp_k_ctx != cur_k_ctx))
  4015a5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4015a8:	48 98                	cltq   
  4015aa:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  4015b1:	00 
  4015b2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4015b6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  4015bb:	74 38                	je     4015f5 <ksched_priority+0x95>
  4015bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4015c1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  4015c5:	74 2e                	je     4015f5 <ksched_priority+0x95>
		{
			if(tmp_k_ctx->kthread_flags & KTHREAD_DONE)
  4015c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4015cb:	8b 40 10             	mov    0x10(%rax),%eax
  4015ce:	83 e0 01             	and    $0x1,%eax
  4015d1:	85 c0                	test   %eax,%eax
  4015d3:	75 1f                	jne    4015f4 <ksched_priority+0x94>
				continue;
			/* tkill : send signal to specific threads */
			syscall(__NR_tkill, tmp_k_ctx->tid, SIGUSR1);
  4015d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4015d9:	8b 40 0c             	mov    0xc(%rax),%eax
  4015dc:	ba 0a 00 00 00       	mov    $0xa,%edx
  4015e1:	89 c6                	mov    %eax,%esi
  4015e3:	bf c8 00 00 00       	mov    $0xc8,%edi
  4015e8:	b8 00 00 00 00       	mov    $0x0,%eax
  4015ed:	e8 5e f5 ff ff       	callq  400b50 <syscall@plt>
  4015f2:	eb 01                	jmp    4015f5 <ksched_priority+0x95>
		/* XXX: We can avoid the last check (tmp to cur) by
		 * temporarily marking cur as DONE. But chuck it !! */
		if((tmp_k_ctx = kthread_cpu_map[inx]) && (tmp_k_ctx != cur_k_ctx))
		{
			if(tmp_k_ctx->kthread_flags & KTHREAD_DONE)
				continue;
  4015f4:	90                   	nop

	cur_k_ctx = kthread_cpu_map[kthread_apic_id()];
	KTHREAD_PRINT_SCHED_DEBUGINFO(cur_k_ctx, "VTALRM");

	/* Relay the signal to all other virtual processors(kthreads) */
	for(inx=0; inx<GT_MAX_KTHREADS; inx++)
  4015f5:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  4015f9:	83 7d ec 0f          	cmpl   $0xf,-0x14(%rbp)
  4015fd:	7e a6                	jle    4015a5 <ksched_priority+0x45>
			/* tkill : send signal to specific threads */
			syscall(__NR_tkill, tmp_k_ctx->tid, SIGUSR1);
		}
	}
	
	uthread_schedule(&sched_find_best_uthread);
  4015ff:	bf 7d 27 40 00       	mov    $0x40277d,%edi
  401604:	e8 82 05 00 00       	callq  401b8b <uthread_schedule>

	//kthread_unblock_signal(SIGVTALRM);
	//kthread_unblock_signal(SIGUSR1);
	return;
  401609:	90                   	nop
}
  40160a:	c9                   	leaveq 
  40160b:	c3                   	retq   

000000000040160c <gtthread_app_start>:
/* gtthread_app_start (kthread_app_func for gtthreads).
 * All application cleanup must be done at the end of this function. */
extern unsigned int gtthread_app_running;

static void gtthread_app_start(void* arg)  // * why void?
{
  40160c:	55                   	push   %rbp
  40160d:	48 89 e5             	mov    %rsp,%rbp
  401610:	53                   	push   %rbx
  401611:	48 83 ec 28          	sub    $0x28,%rsp
  401615:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	kthread_context_t *k_ctx;

	k_ctx = kthread_cpu_map[kthread_apic_id()];
  401619:	e8 a8 fb ff ff       	callq  4011c6 <kthread_apic_id>
  40161e:	0f b6 c0             	movzbl %al,%eax
  401621:	48 98                	cltq   
  401623:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  40162a:	00 
  40162b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert((k_ctx->cpu_apic_id == kthread_apic_id()));
  40162f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401633:	8b 58 04             	mov    0x4(%rax),%ebx
  401636:	e8 8b fb ff ff       	callq  4011c6 <kthread_apic_id>
  40163b:	0f b6 c0             	movzbl %al,%eax
  40163e:	39 c3                	cmp    %eax,%ebx
  401640:	74 40                	je     401682 <gtthread_app_start+0x76>
  401642:	b9 e0 2e 40 00       	mov    $0x402ee0,%ecx
  401647:	ba 19 01 00 00       	mov    $0x119,%edx
  40164c:	be 3f 2e 40 00       	mov    $0x402e3f,%esi
  401651:	bf 50 2e 40 00       	mov    $0x402e50,%edi
  401656:	e8 95 f4 ff ff       	callq  400af0 <__assert_fail@plt>
#if 0
	printf("kthread (%d) ready to schedule", k_ctx->cpuid);
#endif
	while(!(k_ctx->kthread_flags & KTHREAD_DONE))
	{
		__asm__ __volatile__ ("pause\n");
  40165b:	f3 90                	pause  
		if(sigsetjmp(k_ctx->kthread_env, 0))
  40165d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401661:	48 83 c0 38          	add    $0x38,%rax
  401665:	be 00 00 00 00       	mov    $0x0,%esi
  40166a:	48 89 c7             	mov    %rax,%rdi
  40166d:	e8 6e f5 ff ff       	callq  400be0 <__sigsetjmp@plt>
  401672:	85 c0                	test   %eax,%eax
  401674:	75 0f                	jne    401685 <gtthread_app_start+0x79>
			/* siglongjmp to this point is done when there
			 * are no more uthreads to schedule.*/
			/* XXX: gtthread app cleanup has to be done. */
			continue;
		}
		uthread_schedule(&sched_find_best_uthread);
  401676:	bf 7d 27 40 00       	mov    $0x40277d,%edi
  40167b:	e8 0b 05 00 00       	callq  401b8b <uthread_schedule>
  401680:	eb 04                	jmp    401686 <gtthread_app_start+0x7a>
	assert((k_ctx->cpu_apic_id == kthread_apic_id()));

#if 0
	printf("kthread (%d) ready to schedule", k_ctx->cpuid);
#endif
	while(!(k_ctx->kthread_flags & KTHREAD_DONE))
  401682:	90                   	nop
  401683:	eb 01                	jmp    401686 <gtthread_app_start+0x7a>
		if(sigsetjmp(k_ctx->kthread_env, 0))
		{
			/* siglongjmp to this point is done when there
			 * are no more uthreads to schedule.*/
			/* XXX: gtthread app cleanup has to be done. */
			continue;
  401685:	90                   	nop
	assert((k_ctx->cpu_apic_id == kthread_apic_id()));

#if 0
	printf("kthread (%d) ready to schedule", k_ctx->cpuid);
#endif
	while(!(k_ctx->kthread_flags & KTHREAD_DONE))
  401686:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40168a:	8b 40 10             	mov    0x10(%rax),%eax
  40168d:	83 e0 01             	and    $0x1,%eax
  401690:	85 c0                	test   %eax,%eax
  401692:	74 c7                	je     40165b <gtthread_app_start+0x4f>
			/* XXX: gtthread app cleanup has to be done. */
			continue;
		}
		uthread_schedule(&sched_find_best_uthread);
	}
	kthread_exit();
  401694:	b8 00 00 00 00       	mov    $0x0,%eax
  401699:	e8 65 fd ff ff       	callq  401403 <kthread_exit>

	return;
  40169e:	90                   	nop
}
  40169f:	48 83 c4 28          	add    $0x28,%rsp
  4016a3:	5b                   	pop    %rbx
  4016a4:	5d                   	pop    %rbp
  4016a5:	c3                   	retq   

00000000004016a6 <gtthread_app_init>:


extern void gtthread_app_init()
{
  4016a6:	55                   	push   %rbp
  4016a7:	48 89 e5             	mov    %rsp,%rbp
  4016aa:	48 83 ec 30          	sub    $0x30,%rsp
  4016ae:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4016b5:	00 00 
  4016b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4016bb:	31 c0                	xor    %eax,%eax
	kthread_t k_tid;
	unsigned int num_cpus, inx;
	

	/* Initialize shared schedule information */
	ksched_info_init(&ksched_shared_info);
  4016bd:	bf 40 63 60 00       	mov    $0x606340,%edi
  4016c2:	e8 43 fd ff ff       	callq  40140a <ksched_info_init>

	/* kthread (virtual processor) on the first logical processor */
	k_ctx_main = (kthread_context_t *)MALLOCZ_SAFE(sizeof(kthread_context_t));
  4016c7:	bf 58 88 00 00       	mov    $0x8858,%edi
  4016cc:	e8 4a fb ff ff       	callq  40121b <MALLOCZ_SAFE>
  4016d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	k_ctx_main->cpuid = 0;
  4016d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4016d9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	k_ctx_main->kthread_app_func = &gtthread_app_start;
  4016df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4016e3:	48 c7 40 18 0c 16 40 	movq   $0x40160c,0x18(%rax)
  4016ea:	00 
	kthread_init(k_ctx_main);
  4016eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4016ef:	48 89 c7             	mov    %rax,%rdi
  4016f2:	e8 1b fc ff ff       	callq  401312 <kthread_init>

	kthread_init_vtalrm_timeslice();
  4016f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4016fc:	e8 ba 13 00 00       	callq  402abb <kthread_init_vtalrm_timeslice>
	kthread_install_sighandler(SIGVTALRM, k_ctx_main->kthread_sched_timer);
  401701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401705:	48 8b 40 20          	mov    0x20(%rax),%rax
  401709:	48 89 c6             	mov    %rax,%rsi
  40170c:	bf 1a 00 00 00       	mov    $0x1a,%edi
  401711:	e8 0b 12 00 00       	callq  402921 <kthread_install_sighandler>
	kthread_install_sighandler(SIGUSR1, k_ctx_main->kthread_sched_relay);
  401716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40171a:	48 8b 40 28          	mov    0x28(%rax),%rax
  40171e:	48 89 c6             	mov    %rax,%rsi
  401721:	bf 0a 00 00 00       	mov    $0xa,%edi
  401726:	e8 f6 11 00 00       	callq  402921 <kthread_install_sighandler>

	/* Num of logical processors (cpus/cores) */
	num_cpus = (int)sysconf(_SC_NPROCESSORS_CONF);
  40172b:	bf 53 00 00 00       	mov    $0x53,%edi
  401730:	e8 6b f4 ff ff       	callq  400ba0 <sysconf@plt>
  401735:	89 45 e4             	mov    %eax,-0x1c(%rbp)
#if 0
	fprintf(stderr, "Number of cores : %d\n", num_cores);
#endif
	/* kthreads (virtual processors) on all other logical processors */
	for(inx=1; inx<num_cpus; inx++)
  401738:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
  40173f:	eb 7e                	jmp    4017bf <gtthread_app_init+0x119>
	{
		k_ctx = (kthread_context_t *)MALLOCZ_SAFE(sizeof(kthread_context_t));
  401741:	bf 58 88 00 00       	mov    $0x8858,%edi
  401746:	e8 d0 fa ff ff       	callq  40121b <MALLOCZ_SAFE>
  40174b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		k_ctx->cpuid = inx;
  40174f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401753:	8b 55 dc             	mov    -0x24(%rbp),%edx
  401756:	89 10                	mov    %edx,(%rax)
		k_ctx->kthread_app_func = &gtthread_app_start;
  401758:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40175c:	48 c7 40 18 0c 16 40 	movq   $0x40160c,0x18(%rax)
  401763:	00 
		/* kthread_init called inside kthread_handler */
		if(kthread_create(&k_tid, kthread_handler, (void *)k_ctx) < 0)
  401764:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401768:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  40176c:	be e4 12 40 00       	mov    $0x4012e4,%esi
  401771:	48 89 c7             	mov    %rax,%rdi
  401774:	e8 db fa ff ff       	callq  401254 <kthread_create>
  401779:	85 c0                	test   %eax,%eax
  40177b:	79 2a                	jns    4017a7 <gtthread_app_init+0x101>
		{
			fprintf(stderr, "kthread creation failed (errno:%d)\n", errno );
  40177d:	e8 ee f2 ff ff       	callq  400a70 <__errno_location@plt>
  401782:	8b 10                	mov    (%rax),%edx
  401784:	48 8b 05 75 29 20 00 	mov    0x202975(%rip),%rax        # 604100 <__TMC_END__>
  40178b:	be 80 2e 40 00       	mov    $0x402e80,%esi
  401790:	48 89 c7             	mov    %rax,%rdi
  401793:	b8 00 00 00 00       	mov    $0x0,%eax
  401798:	e8 a3 f3 ff ff       	callq  400b40 <fprintf@plt>
			exit(0);
  40179d:	bf 00 00 00 00       	mov    $0x0,%edi
  4017a2:	e8 09 f4 ff ff       	callq  400bb0 <exit@plt>
		}

		printf( "kthread(%d) created !!\n", inx);
  4017a7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4017aa:	89 c6                	mov    %eax,%esi
  4017ac:	bf a4 2e 40 00       	mov    $0x402ea4,%edi
  4017b1:	b8 00 00 00 00       	mov    $0x0,%eax
  4017b6:	e8 05 f3 ff ff       	callq  400ac0 <printf@plt>
	num_cpus = (int)sysconf(_SC_NPROCESSORS_CONF);
#if 0
	fprintf(stderr, "Number of cores : %d\n", num_cores);
#endif
	/* kthreads (virtual processors) on all other logical processors */
	for(inx=1; inx<num_cpus; inx++)
  4017bb:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
  4017bf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4017c2:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  4017c5:	0f 82 76 ff ff ff    	jb     401741 <gtthread_app_init+0x9b>

	{
		/* yield till other kthreads initialize */
		int init_done;
yield_again:
		sched_yield();
  4017cb:	e8 40 f3 ff ff       	callq  400b10 <sched_yield@plt>
		init_done = 0;
  4017d0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		for(inx=0; inx<GT_MAX_KTHREADS; inx++)
  4017d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  4017de:	eb 18                	jmp    4017f8 <gtthread_app_init+0x152>
		{
			/* XXX: We can avoid the last check (tmp to cur) by
			 * temporarily marking cur as DONE. But chuck it !! */
			if(kthread_cpu_map[inx])
  4017e0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4017e3:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  4017ea:	00 
  4017eb:	48 85 c0             	test   %rax,%rax
  4017ee:	74 04                	je     4017f4 <gtthread_app_init+0x14e>
				init_done++;
  4017f0:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
		/* yield till other kthreads initialize */
		int init_done;
yield_again:
		sched_yield();
		init_done = 0;
		for(inx=0; inx<GT_MAX_KTHREADS; inx++)
  4017f4:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
  4017f8:	83 7d dc 0f          	cmpl   $0xf,-0x24(%rbp)
  4017fc:	76 e2                	jbe    4017e0 <gtthread_app_init+0x13a>
			/* XXX: We can avoid the last check (tmp to cur) by
			 * temporarily marking cur as DONE. But chuck it !! */
			if(kthread_cpu_map[inx])
				init_done++;
		}
		assert(init_done <= num_cpus);
  4017fe:	8b 45 e0             	mov    -0x20(%rbp),%eax
  401801:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  401804:	76 19                	jbe    40181f <gtthread_app_init+0x179>
  401806:	b9 00 2f 40 00       	mov    $0x402f00,%ecx
  40180b:	ba 66 01 00 00       	mov    $0x166,%edx
  401810:	be 3f 2e 40 00       	mov    $0x402e3f,%esi
  401815:	bf bc 2e 40 00       	mov    $0x402ebc,%edi
  40181a:	e8 d1 f2 ff ff       	callq  400af0 <__assert_fail@plt>
		if(init_done < num_cpus)
  40181f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  401822:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  401825:	73 02                	jae    401829 <gtthread_app_init+0x183>
			goto yield_again;
  401827:	eb a2                	jmp    4017cb <gtthread_app_init+0x125>

#if 0
	/* app-func is called for main in gthread_app_exit */
	k_ctx_main->kthread_app_func(NULL);
#endif
	return;
  401829:	90                   	nop
}
  40182a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40182e:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  401835:	00 00 
  401837:	74 05                	je     40183e <gtthread_app_init+0x198>
  401839:	e8 72 f2 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  40183e:	c9                   	leaveq 
  40183f:	c3                   	retq   

0000000000401840 <gtthread_app_exit>:

extern void gtthread_app_exit()
{
  401840:	55                   	push   %rbp
  401841:	48 89 e5             	mov    %rsp,%rbp
  401844:	48 83 ec 10          	sub    $0x10,%rsp
	/* gtthread_app_exit called by only main thread. */
	/* For main thread, trigger start again. */
	kthread_context_t *k_ctx;

	k_ctx = kthread_cpu_map[kthread_apic_id()];
  401848:	e8 79 f9 ff ff       	callq  4011c6 <kthread_apic_id>
  40184d:	0f b6 c0             	movzbl %al,%eax
  401850:	48 98                	cltq   
  401852:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401859:	00 
  40185a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	k_ctx->kthread_flags &= ~KTHREAD_DONE;
  40185e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401862:	8b 40 10             	mov    0x10(%rax),%eax
  401865:	83 e0 fe             	and    $0xfffffffe,%eax
  401868:	89 c2                	mov    %eax,%edx
  40186a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40186e:	89 50 10             	mov    %edx,0x10(%rax)

	while(!(k_ctx->kthread_flags & KTHREAD_DONE))
  401871:	eb 28                	jmp    40189b <gtthread_app_exit+0x5b>
	{
		__asm__ __volatile__ ("pause\n");
  401873:	f3 90                	pause  
		if(sigsetjmp(k_ctx->kthread_env, 0))
  401875:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401879:	48 83 c0 38          	add    $0x38,%rax
  40187d:	be 00 00 00 00       	mov    $0x0,%esi
  401882:	48 89 c7             	mov    %rax,%rdi
  401885:	e8 56 f3 ff ff       	callq  400be0 <__sigsetjmp@plt>
  40188a:	85 c0                	test   %eax,%eax
  40188c:	75 0c                	jne    40189a <gtthread_app_exit+0x5a>
			 * are no more uthreads to schedule.*/
			/* XXX: gtthread app cleanup has to be done. */
			continue;
		}
		//printf("kthread: exiting\n");
		uthread_schedule(&sched_find_best_uthread);
  40188e:	bf 7d 27 40 00       	mov    $0x40277d,%edi
  401893:	e8 f3 02 00 00       	callq  401b8b <uthread_schedule>
  401898:	eb 01                	jmp    40189b <gtthread_app_exit+0x5b>
		if(sigsetjmp(k_ctx->kthread_env, 0))
		{
			/* siglongjmp to this point is done when there
			 * are no more uthreads to schedule.*/
			/* XXX: gtthread app cleanup has to be done. */
			continue;
  40189a:	90                   	nop
	kthread_context_t *k_ctx;

	k_ctx = kthread_cpu_map[kthread_apic_id()];
	k_ctx->kthread_flags &= ~KTHREAD_DONE;

	while(!(k_ctx->kthread_flags & KTHREAD_DONE))
  40189b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40189f:	8b 40 10             	mov    0x10(%rax),%eax
  4018a2:	83 e0 01             	and    $0x1,%eax
  4018a5:	85 c0                	test   %eax,%eax
  4018a7:	74 ca                	je     401873 <gtthread_app_exit+0x33>
		}
		//printf("kthread: exiting\n");
		uthread_schedule(&sched_find_best_uthread);
	}

	kthread_block_signal(SIGVTALRM);
  4018a9:	bf 1a 00 00 00       	mov    $0x1a,%edi
  4018ae:	e8 1c 11 00 00       	callq  4029cf <kthread_block_signal>
	kthread_block_signal(SIGUSR1);
  4018b3:	bf 0a 00 00 00       	mov    $0xa,%edi
  4018b8:	e8 12 11 00 00       	callq  4029cf <kthread_block_signal>

	while(ksched_shared_info.kthread_cur_uthreads)
  4018bd:	eb 02                	jmp    4018c1 <gtthread_app_exit+0x81>
	{
		/* Main thread has to wait for other kthreads */
		__asm__ __volatile__ ("pause\n");
  4018bf:	f3 90                	pause  
	}

	kthread_block_signal(SIGVTALRM);
	kthread_block_signal(SIGUSR1);

	while(ksched_shared_info.kthread_cur_uthreads)
  4018c1:	8b 05 85 4a 20 00    	mov    0x204a85(%rip),%eax        # 60634c <ksched_shared_info+0xc>
  4018c7:	85 c0                	test   %eax,%eax
  4018c9:	75 f4                	jne    4018bf <gtthread_app_exit+0x7f>
	{
		/* Main thread has to wait for other kthreads */
		__asm__ __volatile__ ("pause\n");
	}
	return;	
  4018cb:	90                   	nop
}
  4018cc:	c9                   	leaveq 
  4018cd:	c3                   	retq   

00000000004018ce <kthread_apic_id>:
extern int kthread_create(kthread_t *tid, int (*start_fun)(void *), void *arg);

/**********************************************************************/
/* apic-id of the cpu on which kthread is running (kthread_cpu_map) */
static inline unsigned char kthread_apic_id(void)
{
  4018ce:	55                   	push   %rbp
  4018cf:	48 89 e5             	mov    %rsp,%rbp
  4018d2:	53                   	push   %rbx
 * EBX[31:24] Bits 24-31 (8 bits) return the 8-bit unique.
 * Initial APIC ID for the processor this code is running on.*/
#define INITIAL_APIC_ID_BITS  0xFF000000


	unsigned int Regebx = 0;
  4018d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	__asm__ __volatile__ (
  4018da:	b8 01 00 00 00       	mov    $0x1,%eax
  4018df:	0f a2                	cpuid  
  4018e1:	89 de                	mov    %ebx,%esi
  4018e3:	89 75 f4             	mov    %esi,-0xc(%rbp)
		"movl $1, %%eax\n\t"
		"cpuid"
		:"=b" (Regebx)
		: :"%eax","%ecx","%edx");

	return((unsigned char)((Regebx & INITIAL_APIC_ID_BITS) >> 24));
  4018e6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4018e9:	c1 e8 18             	shr    $0x18,%eax
#undef INITIAL_APIC_ID_BITS
}
  4018ec:	5b                   	pop    %rbx
  4018ed:	5d                   	pop    %rbp
  4018ee:	c3                   	retq   

00000000004018ef <MALLOC_SAFE>:


/**********************************************************************/
/* Thread-safe malloc */
static inline void *MALLOC_SAFE(unsigned int size)
{
  4018ef:	55                   	push   %rbp
  4018f0:	48 89 e5             	mov    %rsp,%rbp
  4018f3:	48 83 ec 20          	sub    $0x20,%rsp
  4018f7:	89 7d ec             	mov    %edi,-0x14(%rbp)
	void *__ptr;
	gt_spin_lock(&(ksched_shared_info.__malloc_lock));
  4018fa:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  4018ff:	e8 9e 12 00 00       	callq  402ba2 <gt_spin_lock>
	__ptr = malloc(size);
  401904:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401907:	48 89 c7             	mov    %rax,%rdi
  40190a:	e8 61 f2 ff ff       	callq  400b70 <malloc@plt>
  40190f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	gt_spin_unlock(&(ksched_shared_info.__malloc_lock));
  401913:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  401918:	e8 b2 12 00 00       	callq  402bcf <gt_spin_unlock>
	return(__ptr);
  40191d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401921:	c9                   	leaveq 
  401922:	c3                   	retq   

0000000000401923 <MALLOCZ_SAFE>:

/* Zeroes out allocated bytes */
static inline void *MALLOCZ_SAFE(unsigned int size)
{
  401923:	55                   	push   %rbp
  401924:	48 89 e5             	mov    %rsp,%rbp
  401927:	48 83 ec 20          	sub    $0x20,%rsp
  40192b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	void *__ptr;
	gt_spin_lock(&(ksched_shared_info.__malloc_lock));
  40192e:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  401933:	e8 6a 12 00 00       	callq  402ba2 <gt_spin_lock>
	__ptr = calloc(1, size);
  401938:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40193b:	48 89 c6             	mov    %rax,%rsi
  40193e:	bf 01 00 00 00       	mov    $0x1,%edi
  401943:	e8 e8 f1 ff ff       	callq  400b30 <calloc@plt>
  401948:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	gt_spin_unlock(&(ksched_shared_info.__malloc_lock));
  40194c:	bf a0 63 60 00       	mov    $0x6063a0,%edi
  401951:	e8 79 12 00 00       	callq  402bcf <gt_spin_unlock>
	return(__ptr);
  401956:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40195a:	c9                   	leaveq 
  40195b:	c3                   	retq   

000000000040195c <uthread_init>:
/* uthread scheduling */

/* Assumes that the caller has disabled vtalrm and sigusr1 signals */
/* uthread_init will be using */
static int uthread_init(uthread_struct_t *u_new)
{
  40195c:	55                   	push   %rbp
  40195d:	48 89 e5             	mov    %rsp,%rbp
  401960:	48 81 ec 70 02 00 00 	sub    $0x270,%rsp
  401967:	48 89 bd 98 fd ff ff 	mov    %rdi,-0x268(%rbp)
  40196e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401975:	00 00 
  401977:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40197b:	31 c0                	xor    %eax,%eax
	stack_t oldstack;
	sigset_t set, oldset;
	struct sigaction act, oldact;

	gt_spin_lock(&(ksched_shared_info.uthread_init_lock));
  40197d:	bf 98 63 60 00       	mov    $0x606398,%edi
  401982:	e8 1b 12 00 00       	callq  402ba2 <gt_spin_lock>

	/* Register a signal(SIGUSR2) for alternate stack */
	act.sa_handler = uthread_context_func;
  401987:	48 c7 85 c0 fe ff ff 	movq   $0x401f68,-0x140(%rbp)
  40198e:	68 1f 40 00 
	act.sa_flags = (SA_ONSTACK | SA_RESTART);
  401992:	c7 85 48 ff ff ff 00 	movl   $0x18000000,-0xb8(%rbp)
  401999:	00 00 18 
	if(sigaction(SIGUSR2,&act,&oldact))
  40199c:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
  4019a3:	48 8d 85 c0 fe ff ff 	lea    -0x140(%rbp),%rax
  4019aa:	48 89 c6             	mov    %rax,%rsi
  4019ad:	bf 0c 00 00 00       	mov    $0xc,%edi
  4019b2:	e8 d9 f0 ff ff       	callq  400a90 <sigaction@plt>
  4019b7:	85 c0                	test   %eax,%eax
  4019b9:	74 28                	je     4019e3 <uthread_init+0x87>
	{
		fprintf(stderr, "uthread sigusr2 install failed !!");
  4019bb:	48 8b 05 3e 27 20 00 	mov    0x20273e(%rip),%rax        # 604100 <__TMC_END__>
  4019c2:	48 89 c1             	mov    %rax,%rcx
  4019c5:	ba 21 00 00 00       	mov    $0x21,%edx
  4019ca:	be 01 00 00 00       	mov    $0x1,%esi
  4019cf:	bf 20 2f 40 00       	mov    $0x402f20,%edi
  4019d4:	e8 e7 f1 ff ff       	callq  400bc0 <fwrite@plt>
		return -1;
  4019d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4019de:	e9 92 01 00 00       	jmpq   401b75 <uthread_init+0x219>
	}

	/* Install alternate signal stack (for SIGUSR2) */
	if(sigaltstack(&(u_new->uthread_stack), &oldstack))
  4019e3:	48 8b 85 98 fd ff ff 	mov    -0x268(%rbp),%rax
  4019ea:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  4019f1:	48 8d 85 a0 fd ff ff 	lea    -0x260(%rbp),%rax
  4019f8:	48 89 c6             	mov    %rax,%rsi
  4019fb:	48 89 d7             	mov    %rdx,%rdi
  4019fe:	e8 cd f1 ff ff       	callq  400bd0 <sigaltstack@plt>
  401a03:	85 c0                	test   %eax,%eax
  401a05:	74 28                	je     401a2f <uthread_init+0xd3>
	{
		fprintf(stderr, "uthread sigaltstack install failed.");
  401a07:	48 8b 05 f2 26 20 00 	mov    0x2026f2(%rip),%rax        # 604100 <__TMC_END__>
  401a0e:	48 89 c1             	mov    %rax,%rcx
  401a11:	ba 23 00 00 00       	mov    $0x23,%edx
  401a16:	be 01 00 00 00       	mov    $0x1,%esi
  401a1b:	bf 48 2f 40 00       	mov    $0x402f48,%edi
  401a20:	e8 9b f1 ff ff       	callq  400bc0 <fwrite@plt>
		return -1;
  401a25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401a2a:	e9 46 01 00 00       	jmpq   401b75 <uthread_init+0x219>
	}

	/* Unblock the signal(SIGUSR2) */
	sigemptyset(&set);
  401a2f:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401a36:	48 89 c7             	mov    %rax,%rdi
  401a39:	e8 22 f1 ff ff       	callq  400b60 <sigemptyset@plt>
	sigaddset(&set, SIGUSR2);
  401a3e:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401a45:	be 0c 00 00 00       	mov    $0xc,%esi
  401a4a:	48 89 c7             	mov    %rax,%rdi
  401a4d:	e8 9e f1 ff ff       	callq  400bf0 <sigaddset@plt>
	sigprocmask(SIG_UNBLOCK, &set, &oldset);
  401a52:	48 8d 95 40 fe ff ff 	lea    -0x1c0(%rbp),%rdx
  401a59:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401a60:	48 89 c6             	mov    %rax,%rsi
  401a63:	bf 01 00 00 00       	mov    $0x1,%edi
  401a68:	e8 e3 ef ff ff       	callq  400a50 <sigprocmask@plt>
	/* kthread_runq is made to point to this new thread
	 * in the caller. Raise the signal(SIGUSR2) synchronously */
#if 0
	raise(SIGUSR2);
#endif
	syscall(__NR_tkill, kthread_cpu_map[kthread_apic_id()]->tid, SIGUSR2);
  401a6d:	e8 5c fe ff ff       	callq  4018ce <kthread_apic_id>
  401a72:	0f b6 c0             	movzbl %al,%eax
  401a75:	48 98                	cltq   
  401a77:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401a7e:	00 
  401a7f:	8b 40 0c             	mov    0xc(%rax),%eax
  401a82:	ba 0c 00 00 00       	mov    $0xc,%edx
  401a87:	89 c6                	mov    %eax,%esi
  401a89:	bf c8 00 00 00       	mov    $0xc8,%edi
  401a8e:	b8 00 00 00 00       	mov    $0x0,%eax
  401a93:	e8 b8 f0 ff ff       	callq  400b50 <syscall@plt>
	/* Block the signal(SIGUSR2) */
	sigemptyset(&set);
  401a98:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401a9f:	48 89 c7             	mov    %rax,%rdi
  401aa2:	e8 b9 f0 ff ff       	callq  400b60 <sigemptyset@plt>
	sigaddset(&set, SIGUSR2);
  401aa7:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401aae:	be 0c 00 00 00       	mov    $0xc,%esi
  401ab3:	48 89 c7             	mov    %rax,%rdi
  401ab6:	e8 35 f1 ff ff       	callq  400bf0 <sigaddset@plt>
	sigprocmask(SIG_BLOCK, &set, &oldset);
  401abb:	48 8d 95 40 fe ff ff 	lea    -0x1c0(%rbp),%rdx
  401ac2:	48 8d 85 c0 fd ff ff 	lea    -0x240(%rbp),%rax
  401ac9:	48 89 c6             	mov    %rax,%rsi
  401acc:	bf 00 00 00 00       	mov    $0x0,%edi
  401ad1:	e8 7a ef ff ff       	callq  400a50 <sigprocmask@plt>
	if(sigaction(SIGUSR2,&oldact,NULL))
  401ad6:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  401add:	ba 00 00 00 00       	mov    $0x0,%edx
  401ae2:	48 89 c6             	mov    %rax,%rsi
  401ae5:	bf 0c 00 00 00       	mov    $0xc,%edi
  401aea:	e8 a1 ef ff ff       	callq  400a90 <sigaction@plt>
  401aef:	85 c0                	test   %eax,%eax
  401af1:	74 25                	je     401b18 <uthread_init+0x1bc>
	{
		fprintf(stderr, "uthread sigusr2 revert failed !!");
  401af3:	48 8b 05 06 26 20 00 	mov    0x202606(%rip),%rax        # 604100 <__TMC_END__>
  401afa:	48 89 c1             	mov    %rax,%rcx
  401afd:	ba 20 00 00 00       	mov    $0x20,%edx
  401b02:	be 01 00 00 00       	mov    $0x1,%esi
  401b07:	bf 70 2f 40 00       	mov    $0x402f70,%edi
  401b0c:	e8 af f0 ff ff       	callq  400bc0 <fwrite@plt>
		return -1;
  401b11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401b16:	eb 5d                	jmp    401b75 <uthread_init+0x219>
	}

	/* Disable the stack for signal(SIGUSR2) handling */
	u_new->uthread_stack.ss_flags = SS_DISABLE;
  401b18:	48 8b 85 98 fd ff ff 	mov    -0x268(%rbp),%rax
  401b1f:	c7 80 18 01 00 00 02 	movl   $0x2,0x118(%rax)
  401b26:	00 00 00 

	/* Restore the old stack/signal handling */
	if(sigaltstack(&oldstack, NULL))
  401b29:	48 8d 85 a0 fd ff ff 	lea    -0x260(%rbp),%rax
  401b30:	be 00 00 00 00       	mov    $0x0,%esi
  401b35:	48 89 c7             	mov    %rax,%rdi
  401b38:	e8 93 f0 ff ff       	callq  400bd0 <sigaltstack@plt>
  401b3d:	85 c0                	test   %eax,%eax
  401b3f:	74 25                	je     401b66 <uthread_init+0x20a>
	{
		fprintf(stderr, "uthread sigaltstack revert failed.");
  401b41:	48 8b 05 b8 25 20 00 	mov    0x2025b8(%rip),%rax        # 604100 <__TMC_END__>
  401b48:	48 89 c1             	mov    %rax,%rcx
  401b4b:	ba 22 00 00 00       	mov    $0x22,%edx
  401b50:	be 01 00 00 00       	mov    $0x1,%esi
  401b55:	bf 98 2f 40 00       	mov    $0x402f98,%edi
  401b5a:	e8 61 f0 ff ff       	callq  400bc0 <fwrite@plt>
		return -1;
  401b5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401b64:	eb 0f                	jmp    401b75 <uthread_init+0x219>
	}

	gt_spin_unlock(&(ksched_shared_info.uthread_init_lock));
  401b66:	bf 98 63 60 00       	mov    $0x606398,%edi
  401b6b:	e8 5f 10 00 00       	callq  402bcf <gt_spin_unlock>
	return 0;
  401b70:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401b75:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  401b79:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  401b80:	00 00 
  401b82:	74 05                	je     401b89 <uthread_init+0x22d>
  401b84:	e8 27 ef ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  401b89:	c9                   	leaveq 
  401b8a:	c3                   	retq   

0000000000401b8b <uthread_schedule>:

extern void uthread_schedule(uthread_struct_t * (*kthread_best_sched_uthread)(kthread_runqueue_t *))
{
  401b8b:	55                   	push   %rbp
  401b8c:	48 89 e5             	mov    %rsp,%rbp
  401b8f:	48 83 ec 40          	sub    $0x40,%rsp
  401b93:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

#if 0
	fprintf(stderr, "uthread_schedule invoked !!\n");
#endif

	k_ctx = kthread_cpu_map[kthread_apic_id()];
  401b97:	e8 32 fd ff ff       	callq  4018ce <kthread_apic_id>
  401b9c:	0f b6 c0             	movzbl %al,%eax
  401b9f:	48 98                	cltq   
  401ba1:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401ba8:	00 
  401ba9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	kthread_runq = &(k_ctx->krunqueue);
  401bad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401bb1:	48 05 00 01 00 00    	add    $0x100,%rax
  401bb7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if((u_obj = kthread_runq->cur_uthread))
  401bbb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401bbf:	48 8b 40 18          	mov    0x18(%rax),%rax
  401bc3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  401bc7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  401bcc:	0f 84 87 02 00 00    	je     401e59 <uthread_schedule+0x2ce>
	{
		/*Go through the runq and schedule the next thread to run */
		kthread_runq->cur_uthread = NULL;
  401bd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401bd6:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  401bdd:	00 
		printf("Thread(id:%u), state:%d\n", u_obj->uthread_tid, u_obj->uthread_state);
  401bde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401be2:	8b 10                	mov    (%rax),%edx
  401be4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401be8:	8b 40 10             	mov    0x10(%rax),%eax
  401beb:	89 c6                	mov    %eax,%esi
  401bed:	bf bb 2f 40 00       	mov    $0x402fbb,%edi
  401bf2:	b8 00 00 00 00       	mov    $0x0,%eax
  401bf7:	e8 c4 ee ff ff       	callq  400ac0 <printf@plt>
		if(u_obj->uthread_state & (UTHREAD_DONE | UTHREAD_CANCELLED)) // * Zombie Thread
  401bfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c00:	8b 00                	mov    (%rax),%eax
  401c02:	83 e0 18             	and    $0x18,%eax
  401c05:	85 c0                	test   %eax,%eax
  401c07:	0f 84 df 00 00 00    	je     401cec <uthread_schedule+0x161>
		{
			/* XXX: Inserting uthread into zombie queue is causing improper
			 * cleanup/exit of uthread (core dump) */
			uthread_head_t * kthread_zhead = &(kthread_runq->zombie_uthreads);
  401c0d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401c11:	48 83 c0 28          	add    $0x28,%rax
  401c15:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
			gt_spin_lock(&(kthread_runq->kthread_runqlock));
  401c19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401c1d:	48 83 c0 10          	add    $0x10,%rax
  401c21:	48 89 c7             	mov    %rax,%rdi
  401c24:	e8 79 0f 00 00       	callq  402ba2 <gt_spin_lock>
			kthread_runq->kthread_runqlock.holder = 0x01;
  401c29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401c2d:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)
			TAILQ_INSERT_TAIL(kthread_zhead, u_obj, uthread_runq); // * insert (head*, elm*, field)
  401c34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c38:	48 c7 80 28 01 00 00 	movq   $0x0,0x128(%rax)
  401c3f:	00 00 00 00 
  401c43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401c47:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c4f:	48 89 90 30 01 00 00 	mov    %rdx,0x130(%rax)
  401c56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401c5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  401c5e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401c62:	48 89 10             	mov    %rdx,(%rax)
  401c65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c69:	48 8d 90 28 01 00 00 	lea    0x128(%rax),%rdx
  401c70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401c74:	48 89 50 08          	mov    %rdx,0x8(%rax)
			gt_spin_unlock(&(kthread_runq->kthread_runqlock));
  401c78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401c7c:	48 83 c0 10          	add    $0x10,%rax
  401c80:	48 89 c7             	mov    %rax,%rdi
  401c83:	e8 47 0f 00 00       	callq  402bcf <gt_spin_unlock>
		
			{
				ksched_shared_info_t *ksched_info = &ksched_shared_info;	
  401c88:	48 c7 45 f8 40 63 60 	movq   $0x606340,-0x8(%rbp)
  401c8f:	00 
				gt_spin_lock(&ksched_info->ksched_lock);
  401c90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401c94:	48 83 c0 50          	add    $0x50,%rax
  401c98:	48 89 c7             	mov    %rax,%rdi
  401c9b:	e8 02 0f 00 00       	callq  402ba2 <gt_spin_lock>
				ksched_info->kthread_cur_uthreads--;
  401ca0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401ca4:	8b 40 0c             	mov    0xc(%rax),%eax
  401ca7:	8d 50 ff             	lea    -0x1(%rax),%edx
  401caa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401cae:	89 50 0c             	mov    %edx,0xc(%rax)
				gt_spin_unlock(&ksched_info->ksched_lock);
  401cb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401cb5:	48 83 c0 50          	add    $0x50,%rax
  401cb9:	48 89 c7             	mov    %rax,%rdi
  401cbc:	e8 0e 0f 00 00       	callq  402bcf <gt_spin_unlock>
			}
			printf( "Thread: %u GID: %d CREDITS: %d go to zombie\n", u_obj->uthread_tid, u_obj->uthread_gid, u_obj->credits);
  401cc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401cc5:	8b 48 40             	mov    0x40(%rax),%ecx
  401cc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ccc:	8b 50 14             	mov    0x14(%rax),%edx
  401ccf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401cd3:	8b 40 10             	mov    0x10(%rax),%eax
  401cd6:	89 c6                	mov    %eax,%esi
  401cd8:	bf d8 2f 40 00       	mov    $0x402fd8,%edi
  401cdd:	b8 00 00 00 00       	mov    $0x0,%eax
  401ce2:	e8 d9 ed ff ff       	callq  400ac0 <printf@plt>
  401ce7:	e9 6d 01 00 00       	jmpq   401e59 <uthread_schedule+0x2ce>
			// u_obj->uthread_state = UTHREAD_RUNNABLE;
			// add_to_runqueue(kthread_runq->expires_runq, &(kthread_runq->kthread_runqlock), u_obj);
			// /* XXX: Save the context (signal mask not saved) */
			// if(sigsetjmp(u_obj->uthread_env, 0))
			// 	return;
			printf("credits: %d \n", u_obj->credits);
  401cec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401cf0:	8b 40 40             	mov    0x40(%rax),%eax
  401cf3:	89 c6                	mov    %eax,%esi
  401cf5:	bf 05 30 40 00       	mov    $0x403005,%edi
  401cfa:	b8 00 00 00 00       	mov    $0x0,%eax
  401cff:	e8 bc ed ff ff       	callq  400ac0 <printf@plt>
			if (u_obj->sched_mode == CREDIT_SCHED) {
  401d04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d08:	8b 40 3c             	mov    0x3c(%rax),%eax
  401d0b:	83 f8 16             	cmp    $0x16,%eax
  401d0e:	0f 85 de 00 00 00    	jne    401df2 <uthread_schedule+0x267>
				u_obj->uthread_state = UTHREAD_RUNNABLE;
  401d14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d18:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
				if (u_obj->credits > 0) {
  401d1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d22:	8b 40 40             	mov    0x40(%rax),%eax
  401d25:	85 c0                	test   %eax,%eax
  401d27:	7e 57                	jle    401d80 <uthread_schedule+0x1f5>
					u_obj->credits -= 25;
  401d29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d2d:	8b 40 40             	mov    0x40(%rax),%eax
  401d30:	8d 50 e7             	lea    -0x19(%rax),%edx
  401d33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d37:	89 50 40             	mov    %edx,0x40(%rax)
					add_to_runqueue(kthread_runq->active_runq, &(kthread_runq->kthread_runqlock), u_obj);
  401d3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401d3e:	48 8d 48 10          	lea    0x10(%rax),%rcx
  401d42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401d46:	48 8b 00             	mov    (%rax),%rax
  401d49:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401d4d:	48 89 ce             	mov    %rcx,%rsi
  401d50:	48 89 c7             	mov    %rax,%rdi
  401d53:	e8 c2 08 00 00       	callq  40261a <add_to_runqueue>
					printf("Thread(id:%u) GID: %d CREDITS: %d go to active\n", u_obj->uthread_tid, u_obj->uthread_gid, u_obj->credits);
  401d58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d5c:	8b 48 40             	mov    0x40(%rax),%ecx
  401d5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d63:	8b 50 14             	mov    0x14(%rax),%edx
  401d66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d6a:	8b 40 10             	mov    0x10(%rax),%eax
  401d6d:	89 c6                	mov    %eax,%esi
  401d6f:	bf 18 30 40 00       	mov    $0x403018,%edi
  401d74:	b8 00 00 00 00       	mov    $0x0,%eax
  401d79:	e8 42 ed ff ff       	callq  400ac0 <printf@plt>
  401d7e:	eb 53                	jmp    401dd3 <uthread_schedule+0x248>
				}
				else {
					u_obj->credits = u_obj->credits_set;
  401d80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d84:	8b 50 44             	mov    0x44(%rax),%edx
  401d87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d8b:	89 50 40             	mov    %edx,0x40(%rax)
					add_to_runqueue(kthread_runq->expires_runq, &(kthread_runq->kthread_runqlock), u_obj);
  401d8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401d92:	48 8d 48 10          	lea    0x10(%rax),%rcx
  401d96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401d9a:	48 8b 40 08          	mov    0x8(%rax),%rax
  401d9e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401da2:	48 89 ce             	mov    %rcx,%rsi
  401da5:	48 89 c7             	mov    %rax,%rdi
  401da8:	e8 6d 08 00 00       	callq  40261a <add_to_runqueue>
					printf("Thread(id:%u) GID: %d CREDITS: %d go to expired\n", u_obj->uthread_tid, u_obj->uthread_gid, u_obj->credits);
  401dad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401db1:	8b 48 40             	mov    0x40(%rax),%ecx
  401db4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401db8:	8b 50 14             	mov    0x14(%rax),%edx
  401dbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401dbf:	8b 40 10             	mov    0x10(%rax),%eax
  401dc2:	89 c6                	mov    %eax,%esi
  401dc4:	bf 48 30 40 00       	mov    $0x403048,%edi
  401dc9:	b8 00 00 00 00       	mov    $0x0,%eax
  401dce:	e8 ed ec ff ff       	callq  400ac0 <printf@plt>
				}
				/* XXX: Save the context (signal mask not saved) */
				if(sigsetjmp(u_obj->uthread_env, 0)) {
  401dd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401dd7:	48 83 c0 48          	add    $0x48,%rax
  401ddb:	be 00 00 00 00       	mov    $0x0,%esi
  401de0:	48 89 c7             	mov    %rax,%rdi
  401de3:	e8 f8 ed ff ff       	callq  400be0 <__sigsetjmp@plt>
  401de8:	85 c0                	test   %eax,%eax
  401dea:	0f 85 75 01 00 00    	jne    401f65 <uthread_schedule+0x3da>
  401df0:	eb 67                	jmp    401e59 <uthread_schedule+0x2ce>
					return;
				}
			}
			else if (u_obj->sched_mode == DEFAULT_SCHED) {
  401df2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401df6:	8b 40 3c             	mov    0x3c(%rax),%eax
  401df9:	83 f8 32             	cmp    $0x32,%eax
  401dfc:	75 47                	jne    401e45 <uthread_schedule+0x2ba>
				u_obj->uthread_state = UTHREAD_RUNNABLE;
  401dfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e02:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
				add_to_runqueue(kthread_runq->expires_runq, &(kthread_runq->kthread_runqlock), u_obj);
  401e08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401e0c:	48 8d 48 10          	lea    0x10(%rax),%rcx
  401e10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401e14:	48 8b 40 08          	mov    0x8(%rax),%rax
  401e18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401e1c:	48 89 ce             	mov    %rcx,%rsi
  401e1f:	48 89 c7             	mov    %rax,%rdi
  401e22:	e8 f3 07 00 00       	callq  40261a <add_to_runqueue>
				/* XXX: Save the context (signal mask not saved) */
				if(sigsetjmp(u_obj->uthread_env, 0))
  401e27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e2b:	48 83 c0 48          	add    $0x48,%rax
  401e2f:	be 00 00 00 00       	mov    $0x0,%esi
  401e34:	48 89 c7             	mov    %rax,%rdi
  401e37:	e8 a4 ed ff ff       	callq  400be0 <__sigsetjmp@plt>
  401e3c:	85 c0                	test   %eax,%eax
  401e3e:	74 19                	je     401e59 <uthread_schedule+0x2ce>
					return;
  401e40:	e9 21 01 00 00       	jmpq   401f66 <uthread_schedule+0x3db>
			}
			else{
				printf("Fatal error: Unknown scheduling mode. Quitting...");
  401e45:	bf 80 30 40 00       	mov    $0x403080,%edi
  401e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  401e4f:	e8 6c ec ff ff       	callq  400ac0 <printf@plt>
				return;
  401e54:	e9 0d 01 00 00       	jmpq   401f66 <uthread_schedule+0x3db>
			}
		}
	}

	/* kthread_best_sched_uthread acquires kthread_runqlock. Dont lock it up when calling the function. */
	if(!(u_obj = kthread_best_sched_uthread(kthread_runq)))
  401e59:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401e5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  401e61:	48 89 d7             	mov    %rdx,%rdi
  401e64:	ff d0                	callq  *%rax
  401e66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  401e6a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  401e6f:	75 5b                	jne    401ecc <uthread_schedule+0x341>
	{
		/* Done executing all uthreads. Return to main */
		/* XXX: We can actually get rid of KTHREAD_DONE flag */
		if(ksched_shared_info.kthread_tot_uthreads && !ksched_shared_info.kthread_cur_uthreads)
  401e71:	8b 05 d1 44 20 00    	mov    0x2044d1(%rip),%eax        # 606348 <ksched_shared_info+0x8>
  401e77:	85 c0                	test   %eax,%eax
  401e79:	74 3c                	je     401eb7 <uthread_schedule+0x32c>
  401e7b:	8b 05 cb 44 20 00    	mov    0x2044cb(%rip),%eax        # 60634c <ksched_shared_info+0xc>
  401e81:	85 c0                	test   %eax,%eax
  401e83:	75 32                	jne    401eb7 <uthread_schedule+0x32c>
		{
			fprintf(stderr, "Quitting kthread (%d)\n", k_ctx->cpuid);
  401e85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401e89:	8b 10                	mov    (%rax),%edx
  401e8b:	48 8b 05 6e 22 20 00 	mov    0x20226e(%rip),%rax        # 604100 <__TMC_END__>
  401e92:	be b2 30 40 00       	mov    $0x4030b2,%esi
  401e97:	48 89 c7             	mov    %rax,%rdi
  401e9a:	b8 00 00 00 00       	mov    $0x0,%eax
  401e9f:	e8 9c ec ff ff       	callq  400b40 <fprintf@plt>
			k_ctx->kthread_flags |= KTHREAD_DONE;
  401ea4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401ea8:	8b 40 10             	mov    0x10(%rax),%eax
  401eab:	83 c8 01             	or     $0x1,%eax
  401eae:	89 c2                	mov    %eax,%edx
  401eb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401eb4:	89 50 10             	mov    %edx,0x10(%rax)
		}

		siglongjmp(k_ctx->kthread_env, 1);
  401eb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401ebb:	48 83 c0 38          	add    $0x38,%rax
  401ebf:	be 01 00 00 00       	mov    $0x1,%esi
  401ec4:	48 89 c7             	mov    %rax,%rdi
  401ec7:	e8 04 ec ff ff       	callq  400ad0 <siglongjmp@plt>
		return;
	}

	kthread_runq->cur_uthread = u_obj;
  401ecc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401ed0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401ed4:	48 89 50 18          	mov    %rdx,0x18(%rax)
	if((u_obj->uthread_state == UTHREAD_INIT) && (uthread_init(u_obj)))
  401ed8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401edc:	8b 00                	mov    (%rax),%eax
  401ede:	83 f8 01             	cmp    $0x1,%eax
  401ee1:	75 39                	jne    401f1c <uthread_schedule+0x391>
  401ee3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ee7:	48 89 c7             	mov    %rax,%rdi
  401eea:	e8 6d fa ff ff       	callq  40195c <uthread_init>
  401eef:	85 c0                	test   %eax,%eax
  401ef1:	74 29                	je     401f1c <uthread_schedule+0x391>
	{
		fprintf(stderr, "uthread_init failed on kthread(%d)\n", k_ctx->cpuid);
  401ef3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401ef7:	8b 10                	mov    (%rax),%edx
  401ef9:	48 8b 05 00 22 20 00 	mov    0x202200(%rip),%rax        # 604100 <__TMC_END__>
  401f00:	be d0 30 40 00       	mov    $0x4030d0,%esi
  401f05:	48 89 c7             	mov    %rax,%rdi
  401f08:	b8 00 00 00 00       	mov    $0x0,%eax
  401f0d:	e8 2e ec ff ff       	callq  400b40 <fprintf@plt>
		exit(0);
  401f12:	bf 00 00 00 00       	mov    $0x0,%edi
  401f17:	e8 94 ec ff ff       	callq  400bb0 <exit@plt>
	}

	u_obj->uthread_state = UTHREAD_RUNNING;
  401f1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f20:	c7 00 04 00 00 00    	movl   $0x4,(%rax)
	
	/* Re-install the scheduling signal handlers */
	kthread_install_sighandler(SIGVTALRM, k_ctx->kthread_sched_timer);
  401f26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401f2a:	48 8b 40 20          	mov    0x20(%rax),%rax
  401f2e:	48 89 c6             	mov    %rax,%rsi
  401f31:	bf 1a 00 00 00       	mov    $0x1a,%edi
  401f36:	e8 e6 09 00 00       	callq  402921 <kthread_install_sighandler>
	kthread_install_sighandler(SIGUSR1, k_ctx->kthread_sched_relay);
  401f3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401f3f:	48 8b 40 28          	mov    0x28(%rax),%rax
  401f43:	48 89 c6             	mov    %rax,%rsi
  401f46:	bf 0a 00 00 00       	mov    $0xa,%edi
  401f4b:	e8 d1 09 00 00       	callq  402921 <kthread_install_sighandler>
	/* Jump to the s elected uthread context */
	// printf("Jump!\n");
	siglongjmp(u_obj->uthread_env, 1);
  401f50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f54:	48 83 c0 48          	add    $0x48,%rax
  401f58:	be 01 00 00 00       	mov    $0x1,%esi
  401f5d:	48 89 c7             	mov    %rax,%rdi
  401f60:	e8 6b eb ff ff       	callq  400ad0 <siglongjmp@plt>
					add_to_runqueue(kthread_runq->expires_runq, &(kthread_runq->kthread_runqlock), u_obj);
					printf("Thread(id:%u) GID: %d CREDITS: %d go to expired\n", u_obj->uthread_tid, u_obj->uthread_gid, u_obj->credits);
				}
				/* XXX: Save the context (signal mask not saved) */
				if(sigsetjmp(u_obj->uthread_env, 0)) {
					return;
  401f65:	90                   	nop
	/* Jump to the s elected uthread context */
	// printf("Jump!\n");
	siglongjmp(u_obj->uthread_env, 1);

	return;
}
  401f66:	c9                   	leaveq 
  401f67:	c3                   	retq   

0000000000401f68 <uthread_context_func>:

/* For uthreads, we obtain a seperate stack by registering an alternate
 * stack for SIGUSR2 signal. Once the context is saved, we turn this 
 * into a regular stack for uthread (by using SS_DISABLE). */
static void uthread_context_func(int signo)
{
  401f68:	55                   	push   %rbp
  401f69:	48 89 e5             	mov    %rsp,%rbp
  401f6c:	48 83 ec 50          	sub    $0x50,%rsp
  401f70:	89 7d bc             	mov    %edi,-0x44(%rbp)
  401f73:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401f7a:	00 00 
  401f7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  401f80:	31 c0                	xor    %eax,%eax
	uthread_struct_t *cur_uthread;
	kthread_runqueue_t *kthread_runq;

	kthread_runq = &(kthread_cpu_map[kthread_apic_id()]->krunqueue);
  401f82:	e8 47 f9 ff ff       	callq  4018ce <kthread_apic_id>
  401f87:	0f b6 c0             	movzbl %al,%eax
  401f8a:	48 98                	cltq   
  401f8c:	48 8b 04 c5 c0 63 60 	mov    0x6063c0(,%rax,8),%rax
  401f93:	00 
  401f94:	48 05 00 01 00 00    	add    $0x100,%rax
  401f9a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

	//printf("..... uthread_context_func .....\n");
	/* kthread->cur_uthread points to newly created uthread */
	if(!sigsetjmp(kthread_runq->cur_uthread->uthread_env,0))
  401f9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401fa2:	48 8b 40 18          	mov    0x18(%rax),%rax
  401fa6:	48 83 c0 48          	add    $0x48,%rax
  401faa:	be 00 00 00 00       	mov    $0x0,%esi
  401faf:	48 89 c7             	mov    %rax,%rdi
  401fb2:	e8 29 ec ff ff       	callq  400be0 <__sigsetjmp@plt>
  401fb7:	85 c0                	test   %eax,%eax
  401fb9:	75 3b                	jne    401ff6 <uthread_context_func+0x8e>
	{
		/* In UTHREAD_INIT : saves the context and returns.
		 * Otherwise, continues execution. */
		/* DONT USE any locks here !! */
		assert(kthread_runq->cur_uthread->uthread_state == UTHREAD_INIT);
  401fbb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401fbf:	48 8b 40 18          	mov    0x18(%rax),%rax
  401fc3:	8b 00                	mov    (%rax),%eax
  401fc5:	83 f8 01             	cmp    $0x1,%eax
  401fc8:	74 19                	je     401fe3 <uthread_context_func+0x7b>
  401fca:	b9 f0 31 40 00       	mov    $0x4031f0,%ecx
  401fcf:	ba f3 00 00 00       	mov    $0xf3,%edx
  401fd4:	be f4 30 40 00       	mov    $0x4030f4,%esi
  401fd9:	bf 08 31 40 00       	mov    $0x403108,%edi
  401fde:	e8 0d eb ff ff       	callq  400af0 <__assert_fail@plt>
		kthread_runq->cur_uthread->uthread_state = UTHREAD_RUNNABLE;
  401fe3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401fe7:	48 8b 40 18          	mov    0x18(%rax),%rax
  401feb:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
		return;
  401ff1:	e9 c7 00 00 00       	jmpq   4020bd <uthread_context_func+0x155>
	}

	/* UTHREAD_RUNNING : siglongjmp was executed. */
	cur_uthread = kthread_runq->cur_uthread;
  401ff6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401ffa:	48 8b 40 18          	mov    0x18(%rax),%rax
  401ffe:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cur_uthread->uthread_state == UTHREAD_RUNNING);
  402002:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402006:	8b 00                	mov    (%rax),%eax
  402008:	83 f8 04             	cmp    $0x4,%eax
  40200b:	74 19                	je     402026 <uthread_context_func+0xbe>
  40200d:	b9 f0 31 40 00       	mov    $0x4031f0,%ecx
  402012:	ba fa 00 00 00       	mov    $0xfa,%edx
  402017:	be f4 30 40 00       	mov    $0x4030f4,%esi
  40201c:	bf 48 31 40 00       	mov    $0x403148,%edi
  402021:	e8 ca ea ff ff       	callq  400af0 <__assert_fail@plt>
	/* Execute the uthread task */
	
	struct timeval start_time, end_time;

	gettimeofday(&start_time, NULL);
  402026:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  40202a:	be 00 00 00 00       	mov    $0x0,%esi
  40202f:	48 89 c7             	mov    %rax,%rdi
  402032:	e8 a9 ea ff ff       	callq  400ae0 <gettimeofday@plt>
	cur_uthread->uthread_func(cur_uthread->uthread_arg);
  402037:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40203b:	48 8b 40 18          	mov    0x18(%rax),%rax
  40203f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  402043:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  402047:	48 89 d7             	mov    %rdx,%rdi
  40204a:	ff d0                	callq  *%rax
	gettimeofday(&end_time, NULL);
  40204c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  402050:	be 00 00 00 00       	mov    $0x0,%esi
  402055:	48 89 c7             	mov    %rax,%rdi
  402058:	e8 83 ea ff ff       	callq  400ae0 <gettimeofday@plt>

	printf("Thread(id:%u) thread_func_life:%lu\n", cur_uthread->uthread_tid, (end_time.tv_usec - start_time.tv_usec));
  40205d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402061:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402065:	48 29 c2             	sub    %rax,%rdx
  402068:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40206c:	8b 40 10             	mov    0x10(%rax),%eax
  40206f:	89 c6                	mov    %eax,%esi
  402071:	bf 78 31 40 00       	mov    $0x403178,%edi
  402076:	b8 00 00 00 00       	mov    $0x0,%eax
  40207b:	e8 40 ea ff ff       	callq  400ac0 <printf@plt>
	cur_uthread->uthread_state = UTHREAD_DONE;
  402080:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402084:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

	// ** Block signal
	kthread_block_signal(SIGVTALRM);
  40208a:	bf 1a 00 00 00       	mov    $0x1a,%edi
  40208f:	e8 3b 09 00 00       	callq  4029cf <kthread_block_signal>
	kthread_block_signal(SIGUSR1);
  402094:	bf 0a 00 00 00       	mov    $0xa,%edi
  402099:	e8 31 09 00 00       	callq  4029cf <kthread_block_signal>
	uthread_schedule(&sched_find_best_uthread);
  40209e:	bf 7d 27 40 00       	mov    $0x40277d,%edi
  4020a3:	e8 e3 fa ff ff       	callq  401b8b <uthread_schedule>
	kthread_unblock_signal(SIGVTALRM);
  4020a8:	bf 1a 00 00 00       	mov    $0x1a,%edi
  4020ad:	e8 93 09 00 00       	callq  402a45 <kthread_unblock_signal>
	kthread_unblock_signal(SIGUSR1);
  4020b2:	bf 0a 00 00 00       	mov    $0xa,%edi
  4020b7:	e8 89 09 00 00       	callq  402a45 <kthread_unblock_signal>

	return;
  4020bc:	90                   	nop
}
  4020bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4020c1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4020c8:	00 00 
  4020ca:	74 05                	je     4020d1 <uthread_context_func+0x169>
  4020cc:	e8 df e9 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  4020d1:	c9                   	leaveq 
  4020d2:	c3                   	retq   

00000000004020d3 <uthread_create>:
/* uthread creation */

extern kthread_runqueue_t *ksched_find_target(uthread_struct_t *);

extern int uthread_create(uthread_t *u_tid, int (*u_func)(void *), void *u_arg, uthread_group_t u_gid, int sched_mode, int credits)
{
  4020d3:	55                   	push   %rbp
  4020d4:	48 89 e5             	mov    %rsp,%rbp
  4020d7:	48 83 ec 50          	sub    $0x50,%rsp
  4020db:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  4020df:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  4020e3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  4020e7:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  4020ea:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
  4020ee:	44 89 4d bc          	mov    %r9d,-0x44(%rbp)
	/* Signals used for cpu_thread scheduling */
	// kthread_block_signal(SIGVTALRM);
	// kthread_block_signal(SIGUSR1);

	/* create a new uthread structure and fill it */
	if(!(u_new = (uthread_struct_t *)MALLOCZ_SAFE(sizeof(uthread_struct_t))))
  4020f2:	bf 38 01 00 00       	mov    $0x138,%edi
  4020f7:	e8 27 f8 ff ff       	callq  401923 <MALLOCZ_SAFE>
  4020fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402100:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  402105:	75 28                	jne    40212f <uthread_create+0x5c>
	{
		fprintf(stderr, "uthread mem alloc failure !!");
  402107:	48 8b 05 f2 1f 20 00 	mov    0x201ff2(%rip),%rax        # 604100 <__TMC_END__>
  40210e:	48 89 c1             	mov    %rax,%rcx
  402111:	ba 1c 00 00 00       	mov    $0x1c,%edx
  402116:	be 01 00 00 00       	mov    $0x1,%esi
  40211b:	bf 9c 31 40 00       	mov    $0x40319c,%edi
  402120:	e8 9b ea ff ff       	callq  400bc0 <fwrite@plt>
		exit(0);
  402125:	bf 00 00 00 00       	mov    $0x0,%edi
  40212a:	e8 81 ea ff ff       	callq  400bb0 <exit@plt>
	}

	u_new->uthread_state = UTHREAD_INIT;
  40212f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402133:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	u_new->uthread_priority = DEFAULT_UTHREAD_PRIORITY;
  402139:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40213d:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%rax)
	u_new->uthread_gid = u_gid;
  402144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402148:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  40214b:	89 50 14             	mov    %edx,0x14(%rax)
	u_new->uthread_func = u_func;
  40214e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402152:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  402156:	48 89 50 18          	mov    %rdx,0x18(%rax)
	u_new->uthread_arg = u_arg;
  40215a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40215e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  402162:	48 89 50 20          	mov    %rdx,0x20(%rax)

	// ** Initialize
	u_new->sched_mode = sched_mode; // *cannot directly use u_arg here
  402166:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40216a:	8b 55 c0             	mov    -0x40(%rbp),%edx
  40216d:	89 50 3c             	mov    %edx,0x3c(%rax)
	u_new->credits_set = credits;
  402170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402174:	8b 55 bc             	mov    -0x44(%rbp),%edx
  402177:	89 50 44             	mov    %edx,0x44(%rax)

	u_new->credits = u_new->credits_set;
  40217a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40217e:	8b 50 44             	mov    0x44(%rax),%edx
  402181:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402185:	89 50 40             	mov    %edx,0x40(%rax)


	/* Allocate new stack for uthread */
	u_new->uthread_stack.ss_flags = 0; /* Stack enabled for signal handling */
  402188:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40218c:	c7 80 18 01 00 00 00 	movl   $0x0,0x118(%rax)
  402193:	00 00 00 
	if(!(u_new->uthread_stack.ss_sp = (void *)MALLOC_SAFE(UTHREAD_DEFAULT_SSIZE)))
  402196:	bf 00 40 00 00       	mov    $0x4000,%edi
  40219b:	e8 4f f7 ff ff       	callq  4018ef <MALLOC_SAFE>
  4021a0:	48 89 c2             	mov    %rax,%rdx
  4021a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4021a7:	48 89 90 10 01 00 00 	mov    %rdx,0x110(%rax)
  4021ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4021b2:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
  4021b9:	48 85 c0             	test   %rax,%rax
  4021bc:	75 28                	jne    4021e6 <uthread_create+0x113>
	{
		fprintf(stderr, "uthread stack mem alloc failure !!");
  4021be:	48 8b 05 3b 1f 20 00 	mov    0x201f3b(%rip),%rax        # 604100 <__TMC_END__>
  4021c5:	48 89 c1             	mov    %rax,%rcx
  4021c8:	ba 22 00 00 00       	mov    $0x22,%edx
  4021cd:	be 01 00 00 00       	mov    $0x1,%esi
  4021d2:	bf c0 31 40 00       	mov    $0x4031c0,%edi
  4021d7:	e8 e4 e9 ff ff       	callq  400bc0 <fwrite@plt>
		return -1;
  4021dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4021e1:	e9 a0 00 00 00       	jmpq   402286 <uthread_create+0x1b3>
	}
	u_new->uthread_stack.ss_size = UTHREAD_DEFAULT_SSIZE;
  4021e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4021ea:	48 c7 80 20 01 00 00 	movq   $0x4000,0x120(%rax)
  4021f1:	00 40 00 00 


	{
		ksched_shared_info_t *ksched_info = &ksched_shared_info;
  4021f5:	48 c7 45 f0 40 63 60 	movq   $0x606340,-0x10(%rbp)
  4021fc:	00 

		gt_spin_lock(&ksched_info->ksched_lock);
  4021fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402201:	48 83 c0 50          	add    $0x50,%rax
  402205:	48 89 c7             	mov    %rax,%rdi
  402208:	e8 95 09 00 00       	callq  402ba2 <gt_spin_lock>
		u_new->uthread_tid = ksched_info->kthread_tot_uthreads++;
  40220d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402211:	8b 40 08             	mov    0x8(%rax),%eax
  402214:	8d 48 01             	lea    0x1(%rax),%ecx
  402217:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  40221b:	89 4a 08             	mov    %ecx,0x8(%rdx)
  40221e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402222:	89 42 10             	mov    %eax,0x10(%rdx)
		ksched_info->kthread_cur_uthreads++;
  402225:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402229:	8b 40 0c             	mov    0xc(%rax),%eax
  40222c:	8d 50 01             	lea    0x1(%rax),%edx
  40222f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402233:	89 50 0c             	mov    %edx,0xc(%rax)
		gt_spin_unlock(&ksched_info->ksched_lock);
  402236:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40223a:	48 83 c0 50          	add    $0x50,%rax
  40223e:	48 89 c7             	mov    %rax,%rdi
  402241:	e8 89 09 00 00       	callq  402bcf <gt_spin_unlock>
	}

	/* XXX: ksched_find_target should be a function pointer */
	kthread_runq = ksched_find_target(u_new);
  402246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40224a:	48 89 c7             	mov    %rax,%rdi
  40224d:	e8 06 f2 ff ff       	callq  401458 <ksched_find_target>
  402252:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	*u_tid = u_new->uthread_tid;
  402256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40225a:	8b 50 10             	mov    0x10(%rax),%edx
  40225d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402261:	89 10                	mov    %edx,(%rax)
	/* Queue the uthread for target-cpu. Let target-cpu take care of initialization. */
	//printf("Thread:%d, go to active queue.\n", *u_tid);
	add_to_runqueue(kthread_runq->active_runq, &(kthread_runq->kthread_runqlock), u_new);
  402263:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402267:	48 8d 48 10          	lea    0x10(%rax),%rcx
  40226b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40226f:	48 8b 00             	mov    (%rax),%rax
  402272:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402276:	48 89 ce             	mov    %rcx,%rsi
  402279:	48 89 c7             	mov    %rax,%rdi
  40227c:	e8 99 03 00 00       	callq  40261a <add_to_runqueue>

	/* Resume with the old thread (with all signals enabled) */
	// kthread_unblock_signal(SIGVTALRM);
	// kthread_unblock_signal(SIGUSR1);

	return 0;
  402281:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402286:	c9                   	leaveq 
  402287:	c3                   	retq   

0000000000402288 <__add_to_runqueue>:


/**********************************************************************/
/* runqueue operations */
static inline void __add_to_runqueue(runqueue_t *runq, uthread_struct_t *u_elem)
{
  402288:	55                   	push   %rbp
  402289:	48 89 e5             	mov    %rsp,%rbp
  40228c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402290:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	unsigned int uprio, ugroup;
	uthread_head_t *uhead;

	/* Find a position in the runq based on priority and group.
	 * Update the masks. */
	uprio = u_elem->uthread_priority;
  402294:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402298:	8b 40 04             	mov    0x4(%rax),%eax
  40229b:	89 45 f0             	mov    %eax,-0x10(%rbp)
	ugroup = u_elem->uthread_gid;
  40229e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4022a2:	8b 40 14             	mov    0x14(%rax),%eax
  4022a5:	89 45 f4             	mov    %eax,-0xc(%rbp)

	/* Insert at the tail */
	uhead = &runq->prio_array[uprio].group[ugroup];
  4022a8:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  4022ab:	8b 55 f0             	mov    -0x10(%rbp),%edx
  4022ae:	48 89 d0             	mov    %rdx,%rax
  4022b1:	48 c1 e0 05          	shl    $0x5,%rax
  4022b5:	48 01 d0             	add    %rdx,%rax
  4022b8:	48 01 c8             	add    %rcx,%rax
  4022bb:	48 83 c0 1a          	add    $0x1a,%rax
  4022bf:	48 c1 e0 04          	shl    $0x4,%rax
  4022c3:	48 89 c2             	mov    %rax,%rdx
  4022c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4022ca:	48 01 d0             	add    %rdx,%rax
  4022cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	TAILQ_INSERT_TAIL(uhead, u_elem, uthread_runq);
  4022d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4022d5:	48 c7 80 28 01 00 00 	movq   $0x0,0x128(%rax)
  4022dc:	00 00 00 00 
  4022e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4022e4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4022e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4022ec:	48 89 90 30 01 00 00 	mov    %rdx,0x130(%rax)
  4022f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4022f7:	48 8b 40 08          	mov    0x8(%rax),%rax
  4022fb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4022ff:	48 89 10             	mov    %rdx,(%rax)
  402302:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402306:	48 8d 90 28 01 00 00 	lea    0x128(%rax),%rdx
  40230d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402311:	48 89 50 08          	mov    %rdx,0x8(%rax)

	/* Update information */
	if(!IS_BIT_SET(runq->prio_array[uprio].group_mask, ugroup))
  402315:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402319:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40231c:	48 c1 e0 04          	shl    $0x4,%rax
  402320:	48 89 c1             	mov    %rax,%rcx
  402323:	48 c1 e1 05          	shl    $0x5,%rcx
  402327:	48 01 c8             	add    %rcx,%rax
  40232a:	48 01 d0             	add    %rdx,%rax
  40232d:	48 05 90 01 00 00    	add    $0x190,%rax
  402333:	8b 10                	mov    (%rax),%edx
  402335:	8b 45 f4             	mov    -0xc(%rbp),%eax
  402338:	be 01 00 00 00       	mov    $0x1,%esi
  40233d:	89 c1                	mov    %eax,%ecx
  40233f:	d3 e6                	shl    %cl,%esi
  402341:	89 f0                	mov    %esi,%eax
  402343:	21 d0                	and    %edx,%eax
  402345:	85 c0                	test   %eax,%eax
  402347:	75 25                	jne    40236e <__add_to_runqueue+0xe6>
		SET_BIT(runq->prio_array[uprio].group_mask, ugroup);
  402349:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  40234d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  402350:	48 c1 e0 04          	shl    $0x4,%rax
  402354:	48 89 c1             	mov    %rax,%rcx
  402357:	48 c1 e1 05          	shl    $0x5,%rcx
  40235b:	48 01 c8             	add    %rcx,%rax
  40235e:	48 01 d0             	add    %rdx,%rax
  402361:	48 8d 90 90 01 00 00 	lea    0x190(%rax),%rdx
  402368:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40236b:	0f ab 02             	bts    %eax,(%rdx)

	runq->uthread_tot++;
  40236e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402372:	8b 40 04             	mov    0x4(%rax),%eax
  402375:	8d 50 01             	lea    0x1(%rax),%edx
  402378:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40237c:	89 50 04             	mov    %edx,0x4(%rax)

	runq->uthread_prio_tot[uprio]++;
  40237f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402383:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402386:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  40238a:	8d 48 01             	lea    0x1(%rax),%ecx
  40238d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402391:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402394:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
	if(!IS_BIT_SET(runq->uthread_mask, uprio))
  402398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40239c:	8b 10                	mov    (%rax),%edx
  40239e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4023a1:	be 01 00 00 00       	mov    $0x1,%esi
  4023a6:	89 c1                	mov    %eax,%ecx
  4023a8:	d3 e6                	shl    %cl,%esi
  4023aa:	89 f0                	mov    %esi,%eax
  4023ac:	21 d0                	and    %edx,%eax
  4023ae:	85 c0                	test   %eax,%eax
  4023b0:	75 0a                	jne    4023bc <__add_to_runqueue+0x134>
		SET_BIT(runq->uthread_mask, uprio);
  4023b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023b6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  4023b9:	0f ab 10             	bts    %edx,(%rax)

	runq->uthread_group_tot[ugroup]++;
  4023bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023c0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  4023c3:	48 83 c2 40          	add    $0x40,%rdx
  4023c7:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  4023cb:	8d 48 01             	lea    0x1(%rax),%ecx
  4023ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023d2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  4023d5:	48 83 c2 40          	add    $0x40,%rdx
  4023d9:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
	if(!IS_BIT_SET(runq->uthread_group_mask[ugroup], uprio))
  4023dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023e1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  4023e4:	48 83 c2 20          	add    $0x20,%rdx
  4023e8:	8b 54 90 0c          	mov    0xc(%rax,%rdx,4),%edx
  4023ec:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4023ef:	be 01 00 00 00       	mov    $0x1,%esi
  4023f4:	89 c1                	mov    %eax,%ecx
  4023f6:	d3 e6                	shl    %cl,%esi
  4023f8:	89 f0                	mov    %esi,%eax
  4023fa:	21 d0                	and    %edx,%eax
  4023fc:	85 c0                	test   %eax,%eax
  4023fe:	75 14                	jne    402414 <__add_to_runqueue+0x18c>
		SET_BIT(runq->uthread_group_mask[ugroup], uprio);
  402400:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402404:	8b 55 f4             	mov    -0xc(%rbp),%edx
  402407:	48 8d 4a 20          	lea    0x20(%rdx),%rcx
  40240b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  40240e:	0f ab 54 88 0c       	bts    %edx,0xc(%rax,%rcx,4)

	return;
  402413:	90                   	nop
  402414:	90                   	nop
}
  402415:	5d                   	pop    %rbp
  402416:	c3                   	retq   

0000000000402417 <__rem_from_runqueue>:

static inline void __rem_from_runqueue(runqueue_t *runq, uthread_struct_t *u_elem)
{
  402417:	55                   	push   %rbp
  402418:	48 89 e5             	mov    %rsp,%rbp
  40241b:	48 83 ec 20          	sub    $0x20,%rsp
  40241f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402423:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	unsigned int uprio, ugroup;
	uthread_head_t *uhead;

	/* Find a position in the runq based on priority and group.
	 * Update the masks. */
	uprio = u_elem->uthread_priority;
  402427:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40242b:	8b 40 04             	mov    0x4(%rax),%eax
  40242e:	89 45 f0             	mov    %eax,-0x10(%rbp)
	ugroup = u_elem->uthread_gid;
  402431:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402435:	8b 40 14             	mov    0x14(%rax),%eax
  402438:	89 45 f4             	mov    %eax,-0xc(%rbp)

	/* Insert at the tail */
	uhead = &runq->prio_array[uprio].group[ugroup];
  40243b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  40243e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402441:	48 89 d0             	mov    %rdx,%rax
  402444:	48 c1 e0 05          	shl    $0x5,%rax
  402448:	48 01 d0             	add    %rdx,%rax
  40244b:	48 01 c8             	add    %rcx,%rax
  40244e:	48 83 c0 1a          	add    $0x1a,%rax
  402452:	48 c1 e0 04          	shl    $0x4,%rax
  402456:	48 89 c2             	mov    %rax,%rdx
  402459:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40245d:	48 01 d0             	add    %rdx,%rax
  402460:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	TAILQ_REMOVE(uhead, u_elem, uthread_runq);
  402464:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402468:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  40246f:	48 85 c0             	test   %rax,%rax
  402472:	74 1f                	je     402493 <__rem_from_runqueue+0x7c>
  402474:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402478:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  40247f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402483:	48 8b 92 30 01 00 00 	mov    0x130(%rdx),%rdx
  40248a:	48 89 90 30 01 00 00 	mov    %rdx,0x130(%rax)
  402491:	eb 13                	jmp    4024a6 <__rem_from_runqueue+0x8f>
  402493:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402497:	48 8b 90 30 01 00 00 	mov    0x130(%rax),%rdx
  40249e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4024a2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  4024a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4024aa:	48 8b 80 30 01 00 00 	mov    0x130(%rax),%rax
  4024b1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4024b5:	48 8b 92 28 01 00 00 	mov    0x128(%rdx),%rdx
  4024bc:	48 89 10             	mov    %rdx,(%rax)

	/* Update information */
	if(TAILQ_EMPTY(uhead))
  4024bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4024c3:	48 8b 00             	mov    (%rax),%rax
  4024c6:	48 85 c0             	test   %rax,%rax
  4024c9:	75 25                	jne    4024f0 <__rem_from_runqueue+0xd9>
		RESET_BIT(runq->prio_array[uprio].group_mask, ugroup);
  4024cb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4024cf:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4024d2:	48 c1 e0 04          	shl    $0x4,%rax
  4024d6:	48 89 c1             	mov    %rax,%rcx
  4024d9:	48 c1 e1 05          	shl    $0x5,%rcx
  4024dd:	48 01 c8             	add    %rcx,%rax
  4024e0:	48 01 d0             	add    %rdx,%rax
  4024e3:	48 8d 90 90 01 00 00 	lea    0x190(%rax),%rdx
  4024ea:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4024ed:	0f b3 02             	btr    %eax,(%rdx)

	runq->uthread_tot--;
  4024f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4024f4:	8b 40 04             	mov    0x4(%rax),%eax
  4024f7:	8d 50 ff             	lea    -0x1(%rax),%edx
  4024fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4024fe:	89 50 04             	mov    %edx,0x4(%rax)

	if(!(--(runq->uthread_prio_tot[uprio])))
  402501:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402505:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402508:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  40250c:	8d 48 ff             	lea    -0x1(%rax),%ecx
  40250f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402513:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402516:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
  40251a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40251e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402521:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  402525:	85 c0                	test   %eax,%eax
  402527:	75 0a                	jne    402533 <__rem_from_runqueue+0x11c>
		RESET_BIT(runq->uthread_mask, uprio);
  402529:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40252d:	8b 55 f0             	mov    -0x10(%rbp),%edx
  402530:	0f b3 10             	btr    %edx,(%rax)

	if(!(--(runq->uthread_group_tot[ugroup])))
  402533:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402537:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40253a:	48 83 c2 40          	add    $0x40,%rdx
  40253e:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  402542:	8d 48 ff             	lea    -0x1(%rax),%ecx
  402545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402549:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40254c:	48 83 c2 40          	add    $0x40,%rdx
  402550:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
  402554:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402558:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40255b:	48 83 c2 40          	add    $0x40,%rdx
  40255f:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  402563:	85 c0                	test   %eax,%eax
  402565:	75 39                	jne    4025a0 <__rem_from_runqueue+0x189>
	{
		assert(TAILQ_EMPTY(uhead));
  402567:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40256b:	48 8b 00             	mov    (%rax),%rax
  40256e:	48 85 c0             	test   %rax,%rax
  402571:	74 19                	je     40258c <__rem_from_runqueue+0x175>
  402573:	b9 60 32 40 00       	mov    $0x403260,%ecx
  402578:	ba 50 00 00 00       	mov    $0x50,%edx
  40257d:	be 10 32 40 00       	mov    $0x403210,%esi
  402582:	bf 1c 32 40 00       	mov    $0x40321c,%edi
  402587:	e8 64 e5 ff ff       	callq  400af0 <__assert_fail@plt>
		RESET_BIT(runq->uthread_group_mask[ugroup], uprio);
  40258c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402590:	8b 55 f4             	mov    -0xc(%rbp),%edx
  402593:	48 8d 4a 20          	lea    0x20(%rdx),%rcx
  402597:	8b 55 f0             	mov    -0x10(%rbp),%edx
  40259a:	0f b3 54 88 0c       	btr    %edx,0xc(%rax,%rcx,4)
	}

	return;
  40259f:	90                   	nop
  4025a0:	90                   	nop
}
  4025a1:	c9                   	leaveq 
  4025a2:	c3                   	retq   

00000000004025a3 <init_runqueue>:


/**********************************************************************/
/* Exported runqueue operations */
extern void init_runqueue(runqueue_t *runq)
{
  4025a3:	55                   	push   %rbp
  4025a4:	48 89 e5             	mov    %rsp,%rbp
  4025a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	uthread_head_t *uhead;
	int i, j;
	/* Everything else is global, so already initialized to 0(correct init value) */
	for(i=0; i<MAX_UTHREAD_PRIORITY; i++)
  4025ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  4025b2:	eb 5d                	jmp    402611 <init_runqueue+0x6e>
	{
		for(j=0; j<MAX_UTHREAD_GROUPS; j++)
  4025b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  4025bb:	eb 4a                	jmp    402607 <init_runqueue+0x64>
		{
			uhead = &((runq)->prio_array[i].group[j]);
  4025bd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4025c0:	48 63 c8             	movslq %eax,%rcx
  4025c3:	8b 45 f0             	mov    -0x10(%rbp),%eax
  4025c6:	48 63 d0             	movslq %eax,%rdx
  4025c9:	48 89 d0             	mov    %rdx,%rax
  4025cc:	48 c1 e0 05          	shl    $0x5,%rax
  4025d0:	48 01 d0             	add    %rdx,%rax
  4025d3:	48 01 c8             	add    %rcx,%rax
  4025d6:	48 83 c0 1a          	add    $0x1a,%rax
  4025da:	48 c1 e0 04          	shl    $0x4,%rax
  4025de:	48 89 c2             	mov    %rax,%rdx
  4025e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4025e5:	48 01 d0             	add    %rdx,%rax
  4025e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			TAILQ_INIT(uhead);
  4025ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4025f0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  4025f7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4025fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4025ff:	48 89 50 08          	mov    %rdx,0x8(%rax)
	uthread_head_t *uhead;
	int i, j;
	/* Everything else is global, so already initialized to 0(correct init value) */
	for(i=0; i<MAX_UTHREAD_PRIORITY; i++)
	{
		for(j=0; j<MAX_UTHREAD_GROUPS; j++)
  402603:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  402607:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  40260b:	7e b0                	jle    4025bd <init_runqueue+0x1a>
extern void init_runqueue(runqueue_t *runq)
{
	uthread_head_t *uhead;
	int i, j;
	/* Everything else is global, so already initialized to 0(correct init value) */
	for(i=0; i<MAX_UTHREAD_PRIORITY; i++)
  40260d:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
  402611:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%rbp)
  402615:	7e 9d                	jle    4025b4 <init_runqueue+0x11>
		{
			uhead = &((runq)->prio_array[i].group[j]);
			TAILQ_INIT(uhead);
		}
	}
	return;
  402617:	90                   	nop
}
  402618:	5d                   	pop    %rbp
  402619:	c3                   	retq   

000000000040261a <add_to_runqueue>:

extern void add_to_runqueue(runqueue_t *runq, gt_spinlock_t *runq_lock, uthread_struct_t *u_elem)
{
  40261a:	55                   	push   %rbp
  40261b:	48 89 e5             	mov    %rsp,%rbp
  40261e:	48 83 ec 20          	sub    $0x20,%rsp
  402622:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402626:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40262a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	gt_spin_lock(runq_lock);
  40262e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402632:	48 89 c7             	mov    %rax,%rdi
  402635:	e8 68 05 00 00       	callq  402ba2 <gt_spin_lock>
	runq_lock->holder = 0x02;
  40263a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40263e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
	__add_to_runqueue(runq, u_elem);
  402645:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40264d:	48 89 d6             	mov    %rdx,%rsi
  402650:	48 89 c7             	mov    %rax,%rdi
  402653:	e8 30 fc ff ff       	callq  402288 <__add_to_runqueue>
	gt_spin_unlock(runq_lock);
  402658:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40265c:	48 89 c7             	mov    %rax,%rdi
  40265f:	e8 6b 05 00 00       	callq  402bcf <gt_spin_unlock>
	return;
  402664:	90                   	nop
}
  402665:	c9                   	leaveq 
  402666:	c3                   	retq   

0000000000402667 <rem_from_runqueue>:

extern void rem_from_runqueue(runqueue_t *runq, gt_spinlock_t *runq_lock, uthread_struct_t *u_elem)
{
  402667:	55                   	push   %rbp
  402668:	48 89 e5             	mov    %rsp,%rbp
  40266b:	48 83 ec 20          	sub    $0x20,%rsp
  40266f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402673:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  402677:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	gt_spin_lock(runq_lock);
  40267b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40267f:	48 89 c7             	mov    %rax,%rdi
  402682:	e8 1b 05 00 00       	callq  402ba2 <gt_spin_lock>
	runq_lock->holder = 0x03;
  402687:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40268b:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
	__rem_from_runqueue(runq, u_elem);
  402692:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40269a:	48 89 d6             	mov    %rdx,%rsi
  40269d:	48 89 c7             	mov    %rax,%rdi
  4026a0:	e8 72 fd ff ff       	callq  402417 <__rem_from_runqueue>
	gt_spin_unlock(runq_lock);
  4026a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4026a9:	48 89 c7             	mov    %rax,%rdi
  4026ac:	e8 1e 05 00 00       	callq  402bcf <gt_spin_unlock>
	return;
  4026b1:	90                   	nop
}
  4026b2:	c9                   	leaveq 
  4026b3:	c3                   	retq   

00000000004026b4 <switch_runqueue>:

extern void switch_runqueue(runqueue_t *from_runq, gt_spinlock_t *from_runqlock, 
				runqueue_t *to_runq, gt_spinlock_t *to_runqlock, uthread_struct_t *u_elem)
{
  4026b4:	55                   	push   %rbp
  4026b5:	48 89 e5             	mov    %rsp,%rbp
  4026b8:	48 83 ec 30          	sub    $0x30,%rsp
  4026bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  4026c0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  4026c4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4026c8:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  4026cc:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
	rem_from_runqueue(from_runq, from_runqlock, u_elem);
  4026d0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4026d4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  4026d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4026dc:	48 89 ce             	mov    %rcx,%rsi
  4026df:	48 89 c7             	mov    %rax,%rdi
  4026e2:	e8 80 ff ff ff       	callq  402667 <rem_from_runqueue>
	add_to_runqueue(to_runq, to_runqlock, u_elem);
  4026e7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4026eb:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  4026ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4026f3:	48 89 ce             	mov    %rcx,%rsi
  4026f6:	48 89 c7             	mov    %rax,%rdi
  4026f9:	e8 1c ff ff ff       	callq  40261a <add_to_runqueue>
	return;
  4026fe:	90                   	nop
}
  4026ff:	c9                   	leaveq 
  402700:	c3                   	retq   

0000000000402701 <kthread_init_runqueue>:


/**********************************************************************/

extern void kthread_init_runqueue(kthread_runqueue_t *kthread_runq)
{
  402701:	55                   	push   %rbp
  402702:	48 89 e5             	mov    %rsp,%rbp
  402705:	48 83 ec 10          	sub    $0x10,%rsp
  402709:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	kthread_runq->active_runq = &(kthread_runq->runqueues[0]);
  40270d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402711:	48 8d 50 38          	lea    0x38(%rax),%rdx
  402715:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402719:	48 89 10             	mov    %rdx,(%rax)
	kthread_runq->expires_runq = &(kthread_runq->runqueues[1]);
  40271c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402720:	48 8d 90 c8 43 00 00 	lea    0x43c8(%rax),%rdx
  402727:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40272b:	48 89 50 08          	mov    %rdx,0x8(%rax)

	gt_spinlock_init(&(kthread_runq->kthread_runqlock));
  40272f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402733:	48 83 c0 10          	add    $0x10,%rax
  402737:	48 89 c7             	mov    %rax,%rdi
  40273a:	e8 e0 03 00 00       	callq  402b1f <gt_spinlock_init>
	init_runqueue(kthread_runq->active_runq);
  40273f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402743:	48 8b 00             	mov    (%rax),%rax
  402746:	48 89 c7             	mov    %rax,%rdi
  402749:	e8 55 fe ff ff       	callq  4025a3 <init_runqueue>
	init_runqueue(kthread_runq->expires_runq);
  40274e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402752:	48 8b 40 08          	mov    0x8(%rax),%rax
  402756:	48 89 c7             	mov    %rax,%rdi
  402759:	e8 45 fe ff ff       	callq  4025a3 <init_runqueue>

	TAILQ_INIT(&(kthread_runq->zombie_uthreads));
  40275e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402762:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  402769:	00 
  40276a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40276e:	48 8d 50 28          	lea    0x28(%rax),%rdx
  402772:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402776:	48 89 50 30          	mov    %rdx,0x30(%rax)
	return;
  40277a:	90                   	nop
}
  40277b:	c9                   	leaveq 
  40277c:	c3                   	retq   

000000000040277d <sched_find_best_uthread>:
	return;
}
#endif

extern uthread_struct_t *sched_find_best_uthread(kthread_runqueue_t *kthread_runq)
{
  40277d:	55                   	push   %rbp
  40277e:	48 89 e5             	mov    %rsp,%rbp
  402781:	48 83 ec 40          	sub    $0x40,%rsp
  402785:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	prio_struct_t *prioq;
	uthread_head_t *u_head;
	uthread_struct_t *u_obj;
	unsigned int uprio, ugroup;

	gt_spin_lock(&(kthread_runq->kthread_runqlock));
  402789:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40278d:	48 83 c0 10          	add    $0x10,%rax
  402791:	48 89 c7             	mov    %rax,%rdi
  402794:	e8 09 04 00 00       	callq  402ba2 <gt_spin_lock>

	runq = kthread_runq->active_runq;
  402799:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40279d:	48 8b 00             	mov    (%rax),%rax
  4027a0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	kthread_runq->kthread_runqlock.holder = 0x04;
  4027a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4027a8:	c7 40 14 04 00 00 00 	movl   $0x4,0x14(%rax)
	if(!(runq->uthread_mask))
  4027af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4027b3:	8b 00                	mov    (%rax),%eax
  4027b5:	85 c0                	test   %eax,%eax
  4027b7:	0f 85 93 00 00 00    	jne    402850 <sched_find_best_uthread+0xd3>
	{ /* No jobs in active. switch runqueue */
		assert(!runq->uthread_tot);
  4027bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4027c1:	8b 40 04             	mov    0x4(%rax),%eax
  4027c4:	85 c0                	test   %eax,%eax
  4027c6:	74 19                	je     4027e1 <sched_find_best_uthread+0x64>
  4027c8:	b9 80 32 40 00       	mov    $0x403280,%ecx
  4027cd:	ba c0 00 00 00       	mov    $0xc0,%edx
  4027d2:	be 10 32 40 00       	mov    $0x403210,%esi
  4027d7:	bf 2f 32 40 00       	mov    $0x40322f,%edi
  4027dc:	e8 0f e3 ff ff       	callq  400af0 <__assert_fail@plt>
		kthread_runq->active_runq = kthread_runq->expires_runq;
  4027e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4027e5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4027e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4027ed:	48 89 10             	mov    %rdx,(%rax)
		kthread_runq->expires_runq = runq;
  4027f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4027f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4027f8:	48 89 50 08          	mov    %rdx,0x8(%rax)

		runq = kthread_runq->expires_runq;
  4027fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402800:	48 8b 40 08          	mov    0x8(%rax),%rax
  402804:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(!runq->uthread_mask)
  402808:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40280c:	8b 00                	mov    (%rax),%eax
  40280e:	85 c0                	test   %eax,%eax
  402810:	75 3e                	jne    402850 <sched_find_best_uthread+0xd3>
		{
			assert(!runq->uthread_tot);
  402812:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402816:	8b 40 04             	mov    0x4(%rax),%eax
  402819:	85 c0                	test   %eax,%eax
  40281b:	74 19                	je     402836 <sched_find_best_uthread+0xb9>
  40281d:	b9 80 32 40 00       	mov    $0x403280,%ecx
  402822:	ba c7 00 00 00       	mov    $0xc7,%edx
  402827:	be 10 32 40 00       	mov    $0x403210,%esi
  40282c:	bf 2f 32 40 00       	mov    $0x40322f,%edi
  402831:	e8 ba e2 ff ff       	callq  400af0 <__assert_fail@plt>
			gt_spin_unlock(&(kthread_runq->kthread_runqlock));
  402836:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40283a:	48 83 c0 10          	add    $0x10,%rax
  40283e:	48 89 c7             	mov    %rax,%rdi
  402841:	e8 89 03 00 00       	callq  402bcf <gt_spin_unlock>
			return NULL;
  402846:	b8 00 00 00 00       	mov    $0x0,%eax
  40284b:	e9 b5 00 00 00       	jmpq   402905 <sched_find_best_uthread+0x188>
		}
	}

	/* Find the highest priority bucket */
	uprio = LOWEST_BIT_SET(runq->uthread_mask);
  402850:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402854:	8b 00                	mov    (%rax),%eax
  402856:	0f bc c0             	bsf    %eax,%eax
  402859:	89 45 d0             	mov    %eax,-0x30(%rbp)
  40285c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  40285f:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	prioq = &(runq->prio_array[uprio]);
  402862:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  402865:	48 c1 e0 04          	shl    $0x4,%rax
  402869:	48 89 c2             	mov    %rax,%rdx
  40286c:	48 c1 e2 05          	shl    $0x5,%rdx
  402870:	48 01 d0             	add    %rdx,%rax
  402873:	48 8d 90 90 01 00 00 	lea    0x190(%rax),%rdx
  40287a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40287e:	48 01 d0             	add    %rdx,%rax
  402881:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	assert(prioq->group_mask);
  402885:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402889:	8b 00                	mov    (%rax),%eax
  40288b:	85 c0                	test   %eax,%eax
  40288d:	75 19                	jne    4028a8 <sched_find_best_uthread+0x12b>
  40288f:	b9 80 32 40 00       	mov    $0x403280,%ecx
  402894:	ba d1 00 00 00       	mov    $0xd1,%edx
  402899:	be 10 32 40 00       	mov    $0x403210,%esi
  40289e:	bf 42 32 40 00       	mov    $0x403242,%edi
  4028a3:	e8 48 e2 ff ff       	callq  400af0 <__assert_fail@plt>
	ugroup = LOWEST_BIT_SET(prioq->group_mask);
  4028a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028ac:	8b 00                	mov    (%rax),%eax
  4028ae:	0f bc c0             	bsf    %eax,%eax
  4028b1:	89 45 d8             	mov    %eax,-0x28(%rbp)
  4028b4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  4028b7:	89 45 dc             	mov    %eax,-0x24(%rbp)

	u_head = &(prioq->group[ugroup]);
  4028ba:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4028bd:	48 83 c0 01          	add    $0x1,%rax
  4028c1:	48 c1 e0 04          	shl    $0x4,%rax
  4028c5:	48 89 c2             	mov    %rax,%rdx
  4028c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028cc:	48 01 d0             	add    %rdx,%rax
  4028cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	u_obj = TAILQ_FIRST(u_head);
  4028d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4028d7:	48 8b 00             	mov    (%rax),%rax
  4028da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	__rem_from_runqueue(runq, u_obj);
  4028de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4028e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4028e6:	48 89 d6             	mov    %rdx,%rsi
  4028e9:	48 89 c7             	mov    %rax,%rdi
  4028ec:	e8 26 fb ff ff       	callq  402417 <__rem_from_runqueue>

	gt_spin_unlock(&(kthread_runq->kthread_runqlock));
  4028f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4028f5:	48 83 c0 10          	add    $0x10,%rax
  4028f9:	48 89 c7             	mov    %rax,%rdi
  4028fc:	e8 ce 02 00 00       	callq  402bcf <gt_spin_unlock>
#if 0
	printf("cpu(%d) : sched best uthread(id:%d, group:%d)\n", u_obj->cpu_id, u_obj->uthread_tid, u_obj->uthread_gid);
#endif
	return(u_obj);
  402901:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402905:	c9                   	leaveq 
  402906:	c3                   	retq   

0000000000402907 <sched_find_best_uthread_group>:
/* XXX: More work to be done !!! */
extern gt_spinlock_t uthread_group_penalty_lock;
extern unsigned int uthread_group_penalty;

extern uthread_struct_t *sched_find_best_uthread_group(kthread_runqueue_t *kthread_runq)
{
  402907:	55                   	push   %rbp
  402908:	48 89 e5             	mov    %rsp,%rbp
  40290b:	48 83 ec 10          	sub    $0x10,%rsp
  40290f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	uthread_struct_t *u_obj;
	unsigned int uprio, ugroup, mask;
	uthread_group_t u_gid;

#ifndef COSCHED
	return sched_find_best_uthread(kthread_runq);
  402913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402917:	48 89 c7             	mov    %rax,%rdi
  40291a:	e8 5e fe ff ff       	callq  40277d <sched_find_best_uthread>
	u_head = &(runq->prio_array[uprio].group[u_gid]);
	u_obj = TAILQ_FIRST(u_head);
	rem_from_runqueue(runq, &(kthread_runq->kthread_runqlock), u_obj);
	
	return(u_obj);
}
  40291f:	c9                   	leaveq 
  402920:	c3                   	retq   

0000000000402921 <kthread_install_sighandler>:

/**********************************************************************/
/* kthread signal handling */

extern void kthread_install_sighandler(int signo, void (*handler)(int))
{
  402921:	55                   	push   %rbp
  402922:	48 89 e5             	mov    %rsp,%rbp
  402925:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
  40292c:	89 bd dc fe ff ff    	mov    %edi,-0x124(%rbp)
  402932:	48 89 b5 d0 fe ff ff 	mov    %rsi,-0x130(%rbp)
  402939:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402940:	00 00 
  402942:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402946:	31 c0                	xor    %eax,%eax
	sigset_t set;
	struct sigaction act;

	/* Setup the handler */
	act.sa_handler = handler;
  402948:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  40294f:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
	act.sa_flags = SA_RESTART;
  402956:	c7 45 e8 00 00 00 10 	movl   $0x10000000,-0x18(%rbp)
	sigaction(signo, &act,0);
  40295d:	48 8d 8d 60 ff ff ff 	lea    -0xa0(%rbp),%rcx
  402964:	8b 85 dc fe ff ff    	mov    -0x124(%rbp),%eax
  40296a:	ba 00 00 00 00       	mov    $0x0,%edx
  40296f:	48 89 ce             	mov    %rcx,%rsi
  402972:	89 c7                	mov    %eax,%edi
  402974:	e8 17 e1 ff ff       	callq  400a90 <sigaction@plt>

	/* Unblock the signal */
	sigemptyset(&set);
  402979:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  402980:	48 89 c7             	mov    %rax,%rdi
  402983:	e8 d8 e1 ff ff       	callq  400b60 <sigemptyset@plt>
	sigaddset(&set, signo);
  402988:	8b 95 dc fe ff ff    	mov    -0x124(%rbp),%edx
  40298e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  402995:	89 d6                	mov    %edx,%esi
  402997:	48 89 c7             	mov    %rax,%rdi
  40299a:	e8 51 e2 ff ff       	callq  400bf0 <sigaddset@plt>
	sigprocmask(SIG_UNBLOCK, &set, NULL);
  40299f:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  4029a6:	ba 00 00 00 00       	mov    $0x0,%edx
  4029ab:	48 89 c6             	mov    %rax,%rsi
  4029ae:	bf 01 00 00 00       	mov    $0x1,%edi
  4029b3:	e8 98 e0 ff ff       	callq  400a50 <sigprocmask@plt>

	return;
  4029b8:	90                   	nop
}
  4029b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4029bd:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4029c4:	00 00 
  4029c6:	74 05                	je     4029cd <kthread_install_sighandler+0xac>
  4029c8:	e8 e3 e0 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  4029cd:	c9                   	leaveq 
  4029ce:	c3                   	retq   

00000000004029cf <kthread_block_signal>:

extern void kthread_block_signal(int signo)
{
  4029cf:	55                   	push   %rbp
  4029d0:	48 89 e5             	mov    %rsp,%rbp
  4029d3:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  4029da:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
  4029e0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4029e7:	00 00 
  4029e9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4029ed:	31 c0                	xor    %eax,%eax
	sigset_t set;

	/* Block the signal */
	sigemptyset(&set);
  4029ef:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  4029f6:	48 89 c7             	mov    %rax,%rdi
  4029f9:	e8 62 e1 ff ff       	callq  400b60 <sigemptyset@plt>
	sigaddset(&set, signo);
  4029fe:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  402a04:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  402a0b:	89 d6                	mov    %edx,%esi
  402a0d:	48 89 c7             	mov    %rax,%rdi
  402a10:	e8 db e1 ff ff       	callq  400bf0 <sigaddset@plt>
	sigprocmask(SIG_BLOCK, &set, NULL);
  402a15:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  402a1c:	ba 00 00 00 00       	mov    $0x0,%edx
  402a21:	48 89 c6             	mov    %rax,%rsi
  402a24:	bf 00 00 00 00       	mov    $0x0,%edi
  402a29:	e8 22 e0 ff ff       	callq  400a50 <sigprocmask@plt>

	return;
  402a2e:	90                   	nop
}
  402a2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a33:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402a3a:	00 00 
  402a3c:	74 05                	je     402a43 <kthread_block_signal+0x74>
  402a3e:	e8 6d e0 ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  402a43:	c9                   	leaveq 
  402a44:	c3                   	retq   

0000000000402a45 <kthread_unblock_signal>:

extern void kthread_unblock_signal(int signo)
{
  402a45:	55                   	push   %rbp
  402a46:	48 89 e5             	mov    %rsp,%rbp
  402a49:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  402a50:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
  402a56:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402a5d:	00 00 
  402a5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402a63:	31 c0                	xor    %eax,%eax
	sigset_t set;

	/* Unblock the signal */
	sigemptyset(&set);
  402a65:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  402a6c:	48 89 c7             	mov    %rax,%rdi
  402a6f:	e8 ec e0 ff ff       	callq  400b60 <sigemptyset@plt>
	sigaddset(&set, signo);
  402a74:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  402a7a:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  402a81:	89 d6                	mov    %edx,%esi
  402a83:	48 89 c7             	mov    %rax,%rdi
  402a86:	e8 65 e1 ff ff       	callq  400bf0 <sigaddset@plt>
	sigprocmask(SIG_UNBLOCK, &set, NULL);
  402a8b:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  402a92:	ba 00 00 00 00       	mov    $0x0,%edx
  402a97:	48 89 c6             	mov    %rax,%rsi
  402a9a:	bf 01 00 00 00       	mov    $0x1,%edi
  402a9f:	e8 ac df ff ff       	callq  400a50 <sigprocmask@plt>

	return;
  402aa4:	90                   	nop
}
  402aa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402aa9:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402ab0:	00 00 
  402ab2:	74 05                	je     402ab9 <kthread_unblock_signal+0x74>
  402ab4:	e8 f7 df ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  402ab9:	c9                   	leaveq 
  402aba:	c3                   	retq   

0000000000402abb <kthread_init_vtalrm_timeslice>:

extern void kthread_init_vtalrm_timeslice()
{
  402abb:	55                   	push   %rbp
  402abc:	48 89 e5             	mov    %rsp,%rbp
  402abf:	48 83 ec 30          	sub    $0x30,%rsp
  402ac3:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402aca:	00 00 
  402acc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402ad0:	31 c0                	xor    %eax,%eax
	struct itimerval timeslice;

	timeslice.it_interval.tv_sec = KTHREAD_VTALRM_SEC;
  402ad2:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  402ad9:	00 
	timeslice.it_interval.tv_usec = KTHREAD_VTALRM_USEC;
  402ada:	48 c7 45 d8 98 3a 00 	movq   $0x3a98,-0x28(%rbp)
  402ae1:	00 
	timeslice.it_value.tv_sec = KTHREAD_VTALRM_SEC;
  402ae2:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  402ae9:	00 
	timeslice.it_value.tv_usec = KTHREAD_VTALRM_USEC;
  402aea:	48 c7 45 e8 98 3a 00 	movq   $0x3a98,-0x18(%rbp)
  402af1:	00 

	setitimer(ITIMER_VIRTUAL,&timeslice,NULL);
  402af2:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  402af6:	ba 00 00 00 00       	mov    $0x0,%edx
  402afb:	48 89 c6             	mov    %rax,%rsi
  402afe:	bf 01 00 00 00       	mov    $0x1,%edi
  402b03:	e8 78 e0 ff ff       	callq  400b80 <setitimer@plt>
	return;
  402b08:	90                   	nop
}
  402b09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402b0d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402b14:	00 00 
  402b16:	74 05                	je     402b1d <kthread_init_vtalrm_timeslice+0x62>
  402b18:	e8 93 df ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  402b1d:	c9                   	leaveq 
  402b1e:	c3                   	retq   

0000000000402b1f <gt_spinlock_init>:
/* CANT EXECUTE A BUS LOCKING INSTRUCTION FROM USER MODE SO THIS IS 
 * THE BEST IMPLEMENTATION OF SPINLOCKS I COULD COME UP WITH
 * HAVE NO EFFECT ON A UNIPROCESSOR SYSTEM AS WE DONT NEED LOCKING THERE */

extern int gt_spinlock_init(gt_spinlock_t* spinlock)
{
  402b1f:	55                   	push   %rbp
  402b20:	48 89 e5             	mov    %rsp,%rbp
  402b23:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if(!spinlock)
  402b27:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  402b2c:	75 07                	jne    402b35 <gt_spinlock_init+0x16>
		return -1;
  402b2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402b33:	eb 0f                	jmp    402b44 <gt_spinlock_init+0x25>
	spinlock->locked = 0;
  402b35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402b39:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	return 0;
  402b3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402b44:	5d                   	pop    %rbp
  402b45:	c3                   	retq   

0000000000402b46 <gt_actual_spinlock>:

/* spinlock function with backoff */
void gt_actual_spinlock(volatile int * spinlock)
{
  402b46:	55                   	push   %rbp
  402b47:	48 89 e5             	mov    %rsp,%rbp
  402b4a:	48 83 ec 20          	sub    $0x20,%rsp
  402b4e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402b52:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402b59:	00 00 
  402b5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402b5f:	31 c0                	xor    %eax,%eax
	int sp_val = 1;
  402b61:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
 
	while(sp_val)
  402b68:	eb 1a                	jmp    402b84 <gt_actual_spinlock+0x3e>
	{
		__asm__ __volatile__ ("pause\n");
  402b6a:	f3 90                	pause  
		if(!*((volatile int *)spinlock))
  402b6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b70:	8b 00                	mov    (%rax),%eax
  402b72:	85 c0                	test   %eax,%eax
  402b74:	75 0e                	jne    402b84 <gt_actual_spinlock+0x3e>
		{
		__asm__ __volatile__ (
  402b76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402b7a:	b8 01 00 00 00       	mov    $0x1,%eax
  402b7f:	87 02                	xchg   %eax,(%rdx)
  402b81:	89 45 f4             	mov    %eax,-0xc(%rbp)
/* spinlock function with backoff */
void gt_actual_spinlock(volatile int * spinlock)
{
	int sp_val = 1;
 
	while(sp_val)
  402b84:	8b 45 f4             	mov    -0xc(%rbp),%eax
  402b87:	85 c0                	test   %eax,%eax
  402b89:	75 df                	jne    402b6a <gt_actual_spinlock+0x24>
			:"=m"(sp_val) /* 0 */
			: "r"(spinlock) /* 1 */
			: "%eax"); /* No modified flags or clobbered registers */
		}
	}
	return;
  402b8b:	90                   	nop
}
  402b8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402b90:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402b97:	00 00 
  402b99:	74 05                	je     402ba0 <gt_actual_spinlock+0x5a>
  402b9b:	e8 10 df ff ff       	callq  400ab0 <__stack_chk_fail@plt>
  402ba0:	c9                   	leaveq 
  402ba1:	c3                   	retq   

0000000000402ba2 <gt_spin_lock>:

extern int gt_spin_lock(gt_spinlock_t* spinlock)
{
  402ba2:	55                   	push   %rbp
  402ba3:	48 89 e5             	mov    %rsp,%rbp
  402ba6:	48 83 ec 10          	sub    $0x10,%rsp
  402baa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if(!spinlock)
  402bae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  402bb3:	75 07                	jne    402bbc <gt_spin_lock+0x1a>
		return -1;
  402bb5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402bba:	eb 11                	jmp    402bcd <gt_spin_lock+0x2b>
	gt_actual_spinlock(&(spinlock->locked));
  402bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bc0:	48 89 c7             	mov    %rax,%rdi
  402bc3:	e8 7e ff ff ff       	callq  402b46 <gt_actual_spinlock>
	return 0;	
  402bc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402bcd:	c9                   	leaveq 
  402bce:	c3                   	retq   

0000000000402bcf <gt_spin_unlock>:

extern int gt_spin_unlock(gt_spinlock_t *spinlock)
{
  402bcf:	55                   	push   %rbp
  402bd0:	48 89 e5             	mov    %rsp,%rbp
  402bd3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if(!spinlock)
  402bd7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  402bdc:	75 07                	jne    402be5 <gt_spin_unlock+0x16>
		return -1;
  402bde:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402be3:	eb 19                	jmp    402bfe <gt_spin_unlock+0x2f>
	
	if(spinlock->locked) 
  402be5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402be9:	8b 00                	mov    (%rax),%eax
  402beb:	85 c0                	test   %eax,%eax
  402bed:	74 0a                	je     402bf9 <gt_spin_unlock+0x2a>
		spinlock->locked = 0;
  402bef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bf3:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	   
	return 0;
  402bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402bfe:	5d                   	pop    %rbp
  402bff:	c3                   	retq   

0000000000402c00 <credits_init>:

#include "gt_include.h"
#define NUM_THREADS 128

extern int credits_init(int thread_id)
{
  402c00:	55                   	push   %rbp
  402c01:	48 89 e5             	mov    %rsp,%rbp
  402c04:	48 83 ec 10          	sub    $0x10,%rsp
  402c08:	89 7d fc             	mov    %edi,-0x4(%rbp)
	if (thread_id < 0 || thread_id > 127)
  402c0b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402c0f:	78 06                	js     402c17 <credits_init+0x17>
  402c11:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  402c15:	7e 23                	jle    402c3a <credits_init+0x3a>
	{
		printf(stderr, "Thread exceeds!\n");
  402c17:	48 8b 05 e2 14 20 00 	mov    0x2014e2(%rip),%rax        # 604100 <__TMC_END__>
  402c1e:	be 98 32 40 00       	mov    $0x403298,%esi
  402c23:	48 89 c7             	mov    %rax,%rdi
  402c26:	b8 00 00 00 00       	mov    $0x0,%eax
  402c2b:	e8 90 de ff ff       	callq  400ac0 <printf@plt>
		return -1;
  402c30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402c35:	e9 a4 00 00 00       	jmpq   402cde <credits_init+0xde>
	}
	if(thread_id < 8 || (thread_id > 31 && thread_id < 40) || (thread_id > 63 && thread_id < 72) || (thread_id > 95 && thread_id < 104))
  402c3a:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  402c3e:	7e 24                	jle    402c64 <credits_init+0x64>
  402c40:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  402c44:	7e 06                	jle    402c4c <credits_init+0x4c>
  402c46:	83 7d fc 27          	cmpl   $0x27,-0x4(%rbp)
  402c4a:	7e 18                	jle    402c64 <credits_init+0x64>
  402c4c:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  402c50:	7e 06                	jle    402c58 <credits_init+0x58>
  402c52:	83 7d fc 47          	cmpl   $0x47,-0x4(%rbp)
  402c56:	7e 0c                	jle    402c64 <credits_init+0x64>
  402c58:	83 7d fc 5f          	cmpl   $0x5f,-0x4(%rbp)
  402c5c:	7e 0d                	jle    402c6b <credits_init+0x6b>
  402c5e:	83 7d fc 67          	cmpl   $0x67,-0x4(%rbp)
  402c62:	7f 07                	jg     402c6b <credits_init+0x6b>
		return 25;
  402c64:	b8 19 00 00 00       	mov    $0x19,%eax
  402c69:	eb 73                	jmp    402cde <credits_init+0xde>
	else if ((thread_id >7 && thread_id < 16)|| (thread_id >39 && thread_id < 48)|| (thread_id >71 && thread_id < 80)|| (thread_id >103 && thread_id < 112))
  402c6b:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  402c6f:	7e 06                	jle    402c77 <credits_init+0x77>
  402c71:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  402c75:	7e 24                	jle    402c9b <credits_init+0x9b>
  402c77:	83 7d fc 27          	cmpl   $0x27,-0x4(%rbp)
  402c7b:	7e 06                	jle    402c83 <credits_init+0x83>
  402c7d:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  402c81:	7e 18                	jle    402c9b <credits_init+0x9b>
  402c83:	83 7d fc 47          	cmpl   $0x47,-0x4(%rbp)
  402c87:	7e 06                	jle    402c8f <credits_init+0x8f>
  402c89:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%rbp)
  402c8d:	7e 0c                	jle    402c9b <credits_init+0x9b>
  402c8f:	83 7d fc 67          	cmpl   $0x67,-0x4(%rbp)
  402c93:	7e 0d                	jle    402ca2 <credits_init+0xa2>
  402c95:	83 7d fc 6f          	cmpl   $0x6f,-0x4(%rbp)
  402c99:	7f 07                	jg     402ca2 <credits_init+0xa2>
		return 50;
  402c9b:	b8 32 00 00 00       	mov    $0x32,%eax
  402ca0:	eb 3c                	jmp    402cde <credits_init+0xde>
	else if ((thread_id > 15 && thread_id < 24) ||(thread_id > 47 && thread_id < 56)|| (thread_id > 79 && thread_id < 88) || (thread_id > 111 && thread_id < 120))
  402ca2:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  402ca6:	7e 06                	jle    402cae <credits_init+0xae>
  402ca8:	83 7d fc 17          	cmpl   $0x17,-0x4(%rbp)
  402cac:	7e 24                	jle    402cd2 <credits_init+0xd2>
  402cae:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  402cb2:	7e 06                	jle    402cba <credits_init+0xba>
  402cb4:	83 7d fc 37          	cmpl   $0x37,-0x4(%rbp)
  402cb8:	7e 18                	jle    402cd2 <credits_init+0xd2>
  402cba:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%rbp)
  402cbe:	7e 06                	jle    402cc6 <credits_init+0xc6>
  402cc0:	83 7d fc 57          	cmpl   $0x57,-0x4(%rbp)
  402cc4:	7e 0c                	jle    402cd2 <credits_init+0xd2>
  402cc6:	83 7d fc 6f          	cmpl   $0x6f,-0x4(%rbp)
  402cca:	7e 0d                	jle    402cd9 <credits_init+0xd9>
  402ccc:	83 7d fc 77          	cmpl   $0x77,-0x4(%rbp)
  402cd0:	7f 07                	jg     402cd9 <credits_init+0xd9>
		return 75;
  402cd2:	b8 4b 00 00 00       	mov    $0x4b,%eax
  402cd7:	eb 05                	jmp    402cde <credits_init+0xde>
	else 
		return 100;
  402cd9:	b8 64 00 00 00       	mov    $0x64,%eax
}
  402cde:	c9                   	leaveq 
  402cdf:	c3                   	retq   

0000000000402ce0 <credits_burn>:

extern credits_burn(uthread_struct_t *u_obj)
{
  402ce0:	55                   	push   %rbp
  402ce1:	48 89 e5             	mov    %rsp,%rbp
  402ce4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (u_obj->credits > 0)
  402ce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cec:	8b 40 40             	mov    0x40(%rax),%eax
  402cef:	85 c0                	test   %eax,%eax
  402cf1:	7e 11                	jle    402d04 <credits_burn+0x24>
		u_obj->credits -= 25;
  402cf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cf7:	8b 40 40             	mov    0x40(%rax),%eax
  402cfa:	8d 50 e7             	lea    -0x19(%rax),%edx
  402cfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d01:	89 50 40             	mov    %edx,0x40(%rax)
  402d04:	90                   	nop
  402d05:	5d                   	pop    %rbp
  402d06:	c3                   	retq   
  402d07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  402d0e:	00 00 

0000000000402d10 <__libc_csu_init>:
  402d10:	41 57                	push   %r15
  402d12:	41 56                	push   %r14
  402d14:	41 89 ff             	mov    %edi,%r15d
  402d17:	41 55                	push   %r13
  402d19:	41 54                	push   %r12
  402d1b:	4c 8d 25 ee 10 20 00 	lea    0x2010ee(%rip),%r12        # 603e10 <__frame_dummy_init_array_entry>
  402d22:	55                   	push   %rbp
  402d23:	48 8d 2d ee 10 20 00 	lea    0x2010ee(%rip),%rbp        # 603e18 <__init_array_end>
  402d2a:	53                   	push   %rbx
  402d2b:	49 89 f6             	mov    %rsi,%r14
  402d2e:	49 89 d5             	mov    %rdx,%r13
  402d31:	4c 29 e5             	sub    %r12,%rbp
  402d34:	48 83 ec 08          	sub    $0x8,%rsp
  402d38:	48 c1 fd 03          	sar    $0x3,%rbp
  402d3c:	e8 df dc ff ff       	callq  400a20 <_init>
  402d41:	48 85 ed             	test   %rbp,%rbp
  402d44:	74 20                	je     402d66 <__libc_csu_init+0x56>
  402d46:	31 db                	xor    %ebx,%ebx
  402d48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402d4f:	00 
  402d50:	4c 89 ea             	mov    %r13,%rdx
  402d53:	4c 89 f6             	mov    %r14,%rsi
  402d56:	44 89 ff             	mov    %r15d,%edi
  402d59:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  402d5d:	48 83 c3 01          	add    $0x1,%rbx
  402d61:	48 39 eb             	cmp    %rbp,%rbx
  402d64:	75 ea                	jne    402d50 <__libc_csu_init+0x40>
  402d66:	48 83 c4 08          	add    $0x8,%rsp
  402d6a:	5b                   	pop    %rbx
  402d6b:	5d                   	pop    %rbp
  402d6c:	41 5c                	pop    %r12
  402d6e:	41 5d                	pop    %r13
  402d70:	41 5e                	pop    %r14
  402d72:	41 5f                	pop    %r15
  402d74:	c3                   	retq   
  402d75:	90                   	nop
  402d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402d7d:	00 00 00 

0000000000402d80 <__libc_csu_fini>:
  402d80:	f3 c3                	repz retq 

Disassembly of section .fini:

0000000000402d84 <_fini>:
  402d84:	48 83 ec 08          	sub    $0x8,%rsp
  402d88:	48 83 c4 08          	add    $0x8,%rsp
  402d8c:	c3                   	retq   
